{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to Quick-DEV framework Introduction QuickDev framework is designed to provide enhanced SDK middleware and product ready application reference codes to help developer for fast development. Below diagram is the whole Opulinks provided software architecture combined with QuickDev framework and Opulinks Tritium SDK. App Reference - Provides reference firmware for a complete product demonstration, the application developers can reference the source code and decide which modules to use for fast product developement. Enhanced Middleware - The middleware layer is to integrate common useful functions and features to minimize the effort for application developer for any applications. Tritium SDK - The SDK provided by Opulinks Opulinks github Advantage To provide an easy entry to develop IoT application. To provide application reference modules consist of complete IoT application functions. To provide enhanced Opulinks SDK middleware. Modelized architecture, fulfills different vendor requirement. To provide easy configuration mechanism to config different kind of applications and different modules. To provide cloud template to adapt public/private cloud. To provide pratical usage examples to facilitate developing.","title":"Introduction"},{"location":"index.html#welcome-to-quick-dev-framework","text":"","title":"Welcome to Quick-DEV framework"},{"location":"index.html#introduction","text":"QuickDev framework is designed to provide enhanced SDK middleware and product ready application reference codes to help developer for fast development. Below diagram is the whole Opulinks provided software architecture combined with QuickDev framework and Opulinks Tritium SDK. App Reference - Provides reference firmware for a complete product demonstration, the application developers can reference the source code and decide which modules to use for fast product developement. Enhanced Middleware - The middleware layer is to integrate common useful functions and features to minimize the effort for application developer for any applications. Tritium SDK - The SDK provided by Opulinks Opulinks github","title":"Introduction"},{"location":"index.html#advantage","text":"To provide an easy entry to develop IoT application. To provide application reference modules consist of complete IoT application functions. To provide enhanced Opulinks SDK middleware. Modelized architecture, fulfills different vendor requirement. To provide easy configuration mechanism to config different kind of applications and different modules. To provide cloud template to adapt public/private cloud. To provide pratical usage examples to facilitate developing.","title":"Advantage"},{"location":"api-reference/ble_apis.html","text":"BLE BLE Manager Header File - quick_dev/app_ref/mngr_api/ble_mngr_api.h API List - API Name Opl_Ble_Init_Req Opl_Ble_Start_Req Opl_Ble_Stop_Req Opl_Ble_Uslctd_CB_Reg Opl_Ble_Send_Message Opl_Ble_Service_Assign Opl_Ble_Advertise_Data_Set Opl_Ble_ScanRsp_Data_Set Opl_Ble_EntityGet Opl_Ble_MacAddr_Write Opl_Ble_MacAddr_Read Functions - Opl_Ble_Init_Req Prototype T_OplErr Opl_Ble_Init_Req(uint8_t u8AutoAdvEn); Description \u2003\u2003Ble manager initiate function Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u8AutoAdvEn: \u2003\u2003true -> will enable auto-advertise while disconnect (also will enable advertise after init) \u2003\u2003false -> will not enable auto-advertise while disconnect (also won't enable advertise after init) Opl_Ble_Start_Req Prototype T_OplErr Opl_Ble_Start_Req(uint8_t u8AutoAdvEn); Description \u2003\u2003Start ble advertising Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003U8AutoAdvEn: enable auto-advertise while disconnect Opl_Ble_Stop_Req Prototype T_OplErr Opl_Ble_Stop_Req(void); Description \u2003\u2003Stop ble advertising Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003None Opl_Ble_Uslctd_CB_Reg Prototype T_OplErr Opl_Ble_Uslctd_CB_Reg(T_BmUslctedCbFp fpUslctdCb); Description \u2003\u2003Register unsolicited callback for ble manager Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003fpUslctdCb: unsolicited callback function pointer Opl_Ble_Send_Message Prototype T_OplErr Opl_Ble_Send_Message(uint16_t u16Event, uint8_t *u8Data, uint32_t u32DataLen, uint32_t u32DelayMs); Description \u2003\u2003Send message to task Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16Event: event id (define by user) \u2003\u2003u8Data: data send to ble manager \u2003\u2003u32DataLen: data lens send to ble manager \u2003\u2003u32DelayMs: delay time to trigger event Opl_Ble_Service_Assign Prototype T_OplErr Opl_Ble_Service_Assign(T_BmSvcHandle *ptBmSvcHandle); Description \u2003\u2003Register ble service Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003ptBmSvcHandle: ble service structure Opl_Ble_Advertise_Data_Set Prototype T_OplErr Opl_Ble_Advertise_Data_Set(uint8_t *pau8AdvData, uint8_t u8AdvDataLen); Description \u2003\u2003Setting ble advertise data Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pau8AdvData: advertise data \u2003\u2003u8AdvDataLen: advertise data Len Opl_Ble_ScanRsp_Data_Set Prototype T_OplErr Opl_Ble_ScanRsp_Data_Set(uint8_t *pau8ScanRspData, uint8_t u8ScanRspDataLen); Description \u2003\u2003Setting ble scan respone data Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pau8ScanRspData: scan response data \u2003\u2003u8ScanRspDataLen: scan response data len Opl_Ble_EntityGet Prototype BLE_APP_DATA_T *Opl_Ble_EntityGet(void); Description \u2003\u2003Get ble task entity Return \u2003\u2003G_tTheBle \u2013 success, Other \u2013 failed Parameters \u2003\u2003None Opl_Ble_MacAddr_Write Prototype T_OplErr Opl_Ble_MacAddr_Write(uint8_t *pau8Data); Description \u2003\u2003Write ble mac address Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003Pau8Data: mac address array Opl_Ble_MacAddr_Read Prototype T_OplErr Opl_Ble_MacAddr_Read(uint8_t *pau8Data); Description \u2003\u2003Read ble mac address Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003Pau8Data: mac address array","title":"BluetoothLE"},{"location":"api-reference/ble_apis.html#ble","text":"","title":"BLE"},{"location":"api-reference/ble_apis.html#ble-manager","text":"","title":"BLE Manager"},{"location":"api-reference/ble_apis.html#header-file-","text":"quick_dev/app_ref/mngr_api/ble_mngr_api.h","title":"Header File -"},{"location":"api-reference/ble_apis.html#api-list-","text":"API Name Opl_Ble_Init_Req Opl_Ble_Start_Req Opl_Ble_Stop_Req Opl_Ble_Uslctd_CB_Reg Opl_Ble_Send_Message Opl_Ble_Service_Assign Opl_Ble_Advertise_Data_Set Opl_Ble_ScanRsp_Data_Set Opl_Ble_EntityGet Opl_Ble_MacAddr_Write Opl_Ble_MacAddr_Read","title":"API List -"},{"location":"api-reference/ble_apis.html#functions-","text":"","title":"Functions -"},{"location":"api-reference/ble_apis.html#opl_ble_init_req","text":"Prototype T_OplErr Opl_Ble_Init_Req(uint8_t u8AutoAdvEn); Description \u2003\u2003Ble manager initiate function Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u8AutoAdvEn: \u2003\u2003true -> will enable auto-advertise while disconnect (also will enable advertise after init) \u2003\u2003false -> will not enable auto-advertise while disconnect (also won't enable advertise after init)","title":"Opl_Ble_Init_Req"},{"location":"api-reference/ble_apis.html#opl_ble_start_req","text":"Prototype T_OplErr Opl_Ble_Start_Req(uint8_t u8AutoAdvEn); Description \u2003\u2003Start ble advertising Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003U8AutoAdvEn: enable auto-advertise while disconnect","title":"Opl_Ble_Start_Req"},{"location":"api-reference/ble_apis.html#opl_ble_stop_req","text":"Prototype T_OplErr Opl_Ble_Stop_Req(void); Description \u2003\u2003Stop ble advertising Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003None","title":"Opl_Ble_Stop_Req"},{"location":"api-reference/ble_apis.html#opl_ble_uslctd_cb_reg","text":"Prototype T_OplErr Opl_Ble_Uslctd_CB_Reg(T_BmUslctedCbFp fpUslctdCb); Description \u2003\u2003Register unsolicited callback for ble manager Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003fpUslctdCb: unsolicited callback function pointer","title":"Opl_Ble_Uslctd_CB_Reg"},{"location":"api-reference/ble_apis.html#opl_ble_send_message","text":"Prototype T_OplErr Opl_Ble_Send_Message(uint16_t u16Event, uint8_t *u8Data, uint32_t u32DataLen, uint32_t u32DelayMs); Description \u2003\u2003Send message to task Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16Event: event id (define by user) \u2003\u2003u8Data: data send to ble manager \u2003\u2003u32DataLen: data lens send to ble manager \u2003\u2003u32DelayMs: delay time to trigger event","title":"Opl_Ble_Send_Message"},{"location":"api-reference/ble_apis.html#opl_ble_service_assign","text":"Prototype T_OplErr Opl_Ble_Service_Assign(T_BmSvcHandle *ptBmSvcHandle); Description \u2003\u2003Register ble service Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003ptBmSvcHandle: ble service structure","title":"Opl_Ble_Service_Assign"},{"location":"api-reference/ble_apis.html#opl_ble_advertise_data_set","text":"Prototype T_OplErr Opl_Ble_Advertise_Data_Set(uint8_t *pau8AdvData, uint8_t u8AdvDataLen); Description \u2003\u2003Setting ble advertise data Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pau8AdvData: advertise data \u2003\u2003u8AdvDataLen: advertise data Len","title":"Opl_Ble_Advertise_Data_Set"},{"location":"api-reference/ble_apis.html#opl_ble_scanrsp_data_set","text":"Prototype T_OplErr Opl_Ble_ScanRsp_Data_Set(uint8_t *pau8ScanRspData, uint8_t u8ScanRspDataLen); Description \u2003\u2003Setting ble scan respone data Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pau8ScanRspData: scan response data \u2003\u2003u8ScanRspDataLen: scan response data len","title":"Opl_Ble_ScanRsp_Data_Set"},{"location":"api-reference/ble_apis.html#opl_ble_entityget","text":"Prototype BLE_APP_DATA_T *Opl_Ble_EntityGet(void); Description \u2003\u2003Get ble task entity Return \u2003\u2003G_tTheBle \u2013 success, Other \u2013 failed Parameters \u2003\u2003None","title":"Opl_Ble_EntityGet"},{"location":"api-reference/ble_apis.html#opl_ble_macaddr_write","text":"Prototype T_OplErr Opl_Ble_MacAddr_Write(uint8_t *pau8Data); Description \u2003\u2003Write ble mac address Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003Pau8Data: mac address array","title":"Opl_Ble_MacAddr_Write"},{"location":"api-reference/ble_apis.html#opl_ble_macaddr_read","text":"Prototype T_OplErr Opl_Ble_MacAddr_Read(uint8_t *pau8Data); Description \u2003\u2003Read ble mac address Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003Pau8Data: mac address array","title":"Opl_Ble_MacAddr_Read"},{"location":"api-reference/cloud_apis.html","text":"Cloud Cloud Manager Header File - quick_dev/app_ref/cloud_template/cloud_ctrl.h API List - API Name Cloud_TimerStart Cloud_TimerStop Cloud_InitHandler Cloud_EstablishHandler Cloud_DisconnectHandler Cloud_TimeoutHandler Cloud_BindingHandler Cloud_KeepAliveHandler Cloud_AckHandler Cloud_PostHandler Cloud_BackupRingBufInit Cloud_PostBackupHandler Cloud_ReceiveHandler Functions - Cloud_TimerStart Prototype void Cloud_TimerStart(T_CloudTimerIdx tTmrIdx, uint32_t u32TimeMs); Description \u2003\u2003Start timer function Return \u2003\u2003None Parameters \u2003\u2003tTmrIdx: timer index \u2003\u2003u32TimeMs: timer time in ms Cloud_TimerStop Prototype void Cloud_TimerStop(T_CloudTimerIdx tTmrIdx); Description \u2003\u2003Stop timer function Return \u2003\u2003None Parameters \u2003\u2003tTmrIdx: timer index Cloud_InitHandler Prototype void Cloud_InitHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Cloud init event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens Cloud_EstablishHandler Prototype void Cloud_EstablishHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Establish connection event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens Cloud_DisconnectHandler Prototype void Cloud_DisconnectHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Cloud disconnection event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens Cloud_TimeoutHandler Prototype void Cloud_TimeoutHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Timeout event handler from timer Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens Cloud_BindingHandler Prototype void Cloud_BindingHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Binding request event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens Cloud_KeepAliveHandler Prototype void Cloud_KeepAliveHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Post keep alive event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens Cloud_AckHandler Prototype void Cloud_AckHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Post ack event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens Cloud_PostHandler Prototype void Cloud_PostHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Post data event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens Cloud_BackupRingBufInit Prototype void Cloud_BackupRingBufInit(void); Warning CLOUD_TX_DATA_BACKUP_ENABLED must required Description \u2003\u2003Init ring buffers (will be called at Cloud_Init()) Return \u2003\u2003None Parameters \u2003\u2003None Cloud_PostBackupHandler Prototype void Cloud_PostBackupHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Warning CLOUD_TX_DATA_BACKUP_ENABLED must required Description \u2003\u2003Post the back up data event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens Cloud_ReceiveHandler Prototype void Cloud_ReceiveHandler(void); Description \u2003\u2003Received data from cloud handler Return \u2003\u2003None Parameters \u2003\u2003None","title":"Cloud"},{"location":"api-reference/cloud_apis.html#cloud","text":"","title":"Cloud"},{"location":"api-reference/cloud_apis.html#cloud-manager","text":"","title":"Cloud Manager"},{"location":"api-reference/cloud_apis.html#header-file-","text":"quick_dev/app_ref/cloud_template/cloud_ctrl.h","title":"Header File -"},{"location":"api-reference/cloud_apis.html#api-list-","text":"API Name Cloud_TimerStart Cloud_TimerStop Cloud_InitHandler Cloud_EstablishHandler Cloud_DisconnectHandler Cloud_TimeoutHandler Cloud_BindingHandler Cloud_KeepAliveHandler Cloud_AckHandler Cloud_PostHandler Cloud_BackupRingBufInit Cloud_PostBackupHandler Cloud_ReceiveHandler","title":"API List -"},{"location":"api-reference/cloud_apis.html#functions-","text":"","title":"Functions -"},{"location":"api-reference/cloud_apis.html#cloud_timerstart","text":"Prototype void Cloud_TimerStart(T_CloudTimerIdx tTmrIdx, uint32_t u32TimeMs); Description \u2003\u2003Start timer function Return \u2003\u2003None Parameters \u2003\u2003tTmrIdx: timer index \u2003\u2003u32TimeMs: timer time in ms","title":"Cloud_TimerStart"},{"location":"api-reference/cloud_apis.html#cloud_timerstop","text":"Prototype void Cloud_TimerStop(T_CloudTimerIdx tTmrIdx); Description \u2003\u2003Stop timer function Return \u2003\u2003None Parameters \u2003\u2003tTmrIdx: timer index","title":"Cloud_TimerStop"},{"location":"api-reference/cloud_apis.html#cloud_inithandler","text":"Prototype void Cloud_InitHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Cloud init event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens","title":"Cloud_InitHandler"},{"location":"api-reference/cloud_apis.html#cloud_establishhandler","text":"Prototype void Cloud_EstablishHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Establish connection event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens","title":"Cloud_EstablishHandler"},{"location":"api-reference/cloud_apis.html#cloud_disconnecthandler","text":"Prototype void Cloud_DisconnectHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Cloud disconnection event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens","title":"Cloud_DisconnectHandler"},{"location":"api-reference/cloud_apis.html#cloud_timeouthandler","text":"Prototype void Cloud_TimeoutHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Timeout event handler from timer Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens","title":"Cloud_TimeoutHandler"},{"location":"api-reference/cloud_apis.html#cloud_bindinghandler","text":"Prototype void Cloud_BindingHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Binding request event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens","title":"Cloud_BindingHandler"},{"location":"api-reference/cloud_apis.html#cloud_keepalivehandler","text":"Prototype void Cloud_KeepAliveHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Post keep alive event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens","title":"Cloud_KeepAliveHandler"},{"location":"api-reference/cloud_apis.html#cloud_ackhandler","text":"Prototype void Cloud_AckHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Post ack event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens","title":"Cloud_AckHandler"},{"location":"api-reference/cloud_apis.html#cloud_posthandler","text":"Prototype void Cloud_PostHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Description \u2003\u2003Post data event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens","title":"Cloud_PostHandler"},{"location":"api-reference/cloud_apis.html#cloud_backupringbufinit","text":"Prototype void Cloud_BackupRingBufInit(void); Warning CLOUD_TX_DATA_BACKUP_ENABLED must required Description \u2003\u2003Init ring buffers (will be called at Cloud_Init()) Return \u2003\u2003None Parameters \u2003\u2003None","title":"Cloud_BackupRingBufInit"},{"location":"api-reference/cloud_apis.html#cloud_postbackuphandler","text":"Prototype void Cloud_PostBackupHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen); Warning CLOUD_TX_DATA_BACKUP_ENABLED must required Description \u2003\u2003Post the back up data event handler Return \u2003\u2003None Parameters \u2003\u2003u32EventId: event ID \u2003\u2003pData: message data \u2003\u2003u32DataLen: message data lens","title":"Cloud_PostBackupHandler"},{"location":"api-reference/cloud_apis.html#cloud_receivehandler","text":"Prototype void Cloud_ReceiveHandler(void); Description \u2003\u2003Received data from cloud handler Return \u2003\u2003None Parameters \u2003\u2003None","title":"Cloud_ReceiveHandler"},{"location":"api-reference/opl_error_code.html","text":"OPL Error Code Header File - quick_dev/common/error/opl_err.h Enumeration Table - typedef enum E_OplErr { OPL_OK = 0, OPL_OK_WITH_NO_ACTION, OPL_ERR, OPL_ERR_ALLOC_MEMORY_FAIL, OPL_ERR_PARAM_INVALID, OPL_ERR_CASE_INVALID, OPL_ERR_RTOS_TASK_NOT_INIT, OPL_ERR_RTOS_TASK_REINIT, OPL_ERR_RTOS_QMSG_NOT_INIT, OPL_ERR_RTOS_QMSG_REINIT, OPL_ERR_RTOS_SEND_QMSG_FAIL, OPL_ERR_RTOS_PROC_QMSG_FAIL, OPL_ERR_RTOS_SEM_NOT_INIT, OPL_ERR_RTOS_SEM_REINIT, OPL_ERR_RTOS_EVT_NOT_FOUND, OPL_ERR_FSM_NOT_INIT, OPL_ERR_FSM_REINIT, OPL_ERR_FSM_ST_INVALID, OPL_ERR_FSM_EVT_INVALID, OPL_ERR_IND_CB_REG_INVALID, OPL_ERR_IND_CB_NOT_RELATED, OPL_ERR_USLCTED_CB_REG_INVALID, OPL_ERR_WIFI_EVTLOOP_REINIT, OPL_ERR_WIFI_SCAN_CMD_FAIL, OPL_ERR_WIFI_SCAN_CMD_TIMEOUT, OPL_ERR_WIFI_SCAN_FAIL, OPL_ERR_WIFI_SCAN_NO_AP, OPL_ERR_WIFI_AC_CMD_FAIL, OPL_ERR_WIFI_AC_LIST_EMPTY, OPL_ERR_WIFI_CONNECT_CMD_FAIL, OPL_ERR_WIFI_CONNECT_CMD_TIMEOUT, OPL_ERR_WIFI_CONNECT_FAIL, OPL_ERR_WIFI_DISCONNECT_CMD_FAIL, OPL_ERR_WIFI_DISCONNECT_CMD_TIMEOUT, OPL_ERR_WIFI_DISCONNECT_FAIL, OPL_ERR_BLE_TASK_REINIT, OPL_ERR_BLE_SVC_ASSIGN_INVALID, OPL_ERR_BLE_ENT_ADV_CMD_FAIL, OPL_ERR_BLE_ENT_ADV_FAIL, OPL_ERR_BLE_EXI_ADV_CMD_FAIL, OPL_ERR_BLE_EXI_ADV_FAIL, OPL_ERR_BLE_CONNECT_FAIL, OPL_ERR_BLE_DISCONNECT_CMD_FAIL, OPL_ERR_BLE_DISCONNECT_FAIL, OPL_OTA_SEQ_ERROR, OPL_OTA_FAIL, OPL_OTA_TIMEOUT, OPL_ERR_CODE_TOTAL, } T_OplErr;","title":"OPL Error Code"},{"location":"api-reference/opl_error_code.html#opl-error-code","text":"","title":"OPL Error Code"},{"location":"api-reference/opl_error_code.html#header-file-","text":"quick_dev/common/error/opl_err.h","title":"Header File -"},{"location":"api-reference/opl_error_code.html#enumeration-table-","text":"typedef enum E_OplErr { OPL_OK = 0, OPL_OK_WITH_NO_ACTION, OPL_ERR, OPL_ERR_ALLOC_MEMORY_FAIL, OPL_ERR_PARAM_INVALID, OPL_ERR_CASE_INVALID, OPL_ERR_RTOS_TASK_NOT_INIT, OPL_ERR_RTOS_TASK_REINIT, OPL_ERR_RTOS_QMSG_NOT_INIT, OPL_ERR_RTOS_QMSG_REINIT, OPL_ERR_RTOS_SEND_QMSG_FAIL, OPL_ERR_RTOS_PROC_QMSG_FAIL, OPL_ERR_RTOS_SEM_NOT_INIT, OPL_ERR_RTOS_SEM_REINIT, OPL_ERR_RTOS_EVT_NOT_FOUND, OPL_ERR_FSM_NOT_INIT, OPL_ERR_FSM_REINIT, OPL_ERR_FSM_ST_INVALID, OPL_ERR_FSM_EVT_INVALID, OPL_ERR_IND_CB_REG_INVALID, OPL_ERR_IND_CB_NOT_RELATED, OPL_ERR_USLCTED_CB_REG_INVALID, OPL_ERR_WIFI_EVTLOOP_REINIT, OPL_ERR_WIFI_SCAN_CMD_FAIL, OPL_ERR_WIFI_SCAN_CMD_TIMEOUT, OPL_ERR_WIFI_SCAN_FAIL, OPL_ERR_WIFI_SCAN_NO_AP, OPL_ERR_WIFI_AC_CMD_FAIL, OPL_ERR_WIFI_AC_LIST_EMPTY, OPL_ERR_WIFI_CONNECT_CMD_FAIL, OPL_ERR_WIFI_CONNECT_CMD_TIMEOUT, OPL_ERR_WIFI_CONNECT_FAIL, OPL_ERR_WIFI_DISCONNECT_CMD_FAIL, OPL_ERR_WIFI_DISCONNECT_CMD_TIMEOUT, OPL_ERR_WIFI_DISCONNECT_FAIL, OPL_ERR_BLE_TASK_REINIT, OPL_ERR_BLE_SVC_ASSIGN_INVALID, OPL_ERR_BLE_ENT_ADV_CMD_FAIL, OPL_ERR_BLE_ENT_ADV_FAIL, OPL_ERR_BLE_EXI_ADV_CMD_FAIL, OPL_ERR_BLE_EXI_ADV_FAIL, OPL_ERR_BLE_CONNECT_FAIL, OPL_ERR_BLE_DISCONNECT_CMD_FAIL, OPL_ERR_BLE_DISCONNECT_FAIL, OPL_OTA_SEQ_ERROR, OPL_OTA_FAIL, OPL_OTA_TIMEOUT, OPL_ERR_CODE_TOTAL, } T_OplErr;","title":"Enumeration Table -"},{"location":"api-reference/ota_apis.html","text":"OTA OTA Manager Header File quick_dev/common/ota/ota_mngr.h API List API Name OTA_Init OTA_CurrentVersionGet OTA_UpgradeBegin OTA_WriteData OTA_UpgradeFinish OTA_UpgradeGiveUp OTA_TriggerReboot Functions OTA_Init Prototype void OTA_Init(void); Description \u2003\u2003OTA manager initiate function Return \u2003\u2003None Parameters \u2003\u2003None OTA_CurrentVersionGet Prototype T_OplErr OTA_CurrentVersionGet(uint16_t *u16PrjId, uint16_t *u16ChipId, uint16_t *u16FwId); Description \u2003\u2003Get current OTA version Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16PrjId: current project ID \u2003\u2003u16ChipId: current chip ID \u2003\u2003u16FwId: current firmware version OTA_UpgradeBegin Prototype T_OplErr OTA_UpgradeBegin(uint16_t *pu16SeqId, T_MwOtaFlashHeader *ptOtaHdr, T_OtaProcTimeoutIndCbFp tOtaProcTimeoutIndCb); Description \u2003\u2003Begin OTA upgrade Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pu16SeqId: OTA sequence number \u2003\u2003ptOtaHdr: \u2003\u2003tOtaProcTimeoutIndCb: OTA_WriteData Prototype T_OplErr OTA_WriteData(uint16_t u16SeqId, uint8_t *pu8Data, uint32_t u32DataLen); Description \u2003\u2003Write OTA raw data function Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16SeqId: OTA sequence number \u2003\u2003pu8Data: OTA raw data \u2003\u2003u32DataLen: OTA raw data lens OTA_UpgradeFinish Prototype T_OplErr OTA_UpgradeFinish(uint16_t u16SeqId); Description \u2003\u2003Finish OTA upgrade function, if OTA upgrade successfully Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16SeqId: OTA sequence number OTA_UpgradeGiveUp Prototype T_OplErr OTA_UpgradeGiveUp(uint16_t u16SeqId); Description \u2003\u2003Give up OTA upgrade Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16SeqId: OTA sequence number OTA_TriggerReboot Prototype T_OplErr OTA_TriggerReboot(uint16_t u16Delay); Description \u2003\u2003Reboot after OTA update successfully Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16Delay: delay timer (ms) to trgger reboot","title":"OTA"},{"location":"api-reference/ota_apis.html#ota","text":"","title":"OTA"},{"location":"api-reference/ota_apis.html#ota-manager","text":"","title":"OTA Manager"},{"location":"api-reference/ota_apis.html#header-file","text":"quick_dev/common/ota/ota_mngr.h","title":"Header File"},{"location":"api-reference/ota_apis.html#api-list","text":"API Name OTA_Init OTA_CurrentVersionGet OTA_UpgradeBegin OTA_WriteData OTA_UpgradeFinish OTA_UpgradeGiveUp OTA_TriggerReboot","title":"API List"},{"location":"api-reference/ota_apis.html#functions","text":"","title":"Functions"},{"location":"api-reference/ota_apis.html#ota_init","text":"Prototype void OTA_Init(void); Description \u2003\u2003OTA manager initiate function Return \u2003\u2003None Parameters \u2003\u2003None","title":"OTA_Init"},{"location":"api-reference/ota_apis.html#ota_currentversionget","text":"Prototype T_OplErr OTA_CurrentVersionGet(uint16_t *u16PrjId, uint16_t *u16ChipId, uint16_t *u16FwId); Description \u2003\u2003Get current OTA version Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16PrjId: current project ID \u2003\u2003u16ChipId: current chip ID \u2003\u2003u16FwId: current firmware version","title":"OTA_CurrentVersionGet"},{"location":"api-reference/ota_apis.html#ota_upgradebegin","text":"Prototype T_OplErr OTA_UpgradeBegin(uint16_t *pu16SeqId, T_MwOtaFlashHeader *ptOtaHdr, T_OtaProcTimeoutIndCbFp tOtaProcTimeoutIndCb); Description \u2003\u2003Begin OTA upgrade Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pu16SeqId: OTA sequence number \u2003\u2003ptOtaHdr: \u2003\u2003tOtaProcTimeoutIndCb:","title":"OTA_UpgradeBegin"},{"location":"api-reference/ota_apis.html#ota_writedata","text":"Prototype T_OplErr OTA_WriteData(uint16_t u16SeqId, uint8_t *pu8Data, uint32_t u32DataLen); Description \u2003\u2003Write OTA raw data function Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16SeqId: OTA sequence number \u2003\u2003pu8Data: OTA raw data \u2003\u2003u32DataLen: OTA raw data lens","title":"OTA_WriteData"},{"location":"api-reference/ota_apis.html#ota_upgradefinish","text":"Prototype T_OplErr OTA_UpgradeFinish(uint16_t u16SeqId); Description \u2003\u2003Finish OTA upgrade function, if OTA upgrade successfully Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16SeqId: OTA sequence number","title":"OTA_UpgradeFinish"},{"location":"api-reference/ota_apis.html#ota_upgradegiveup","text":"Prototype T_OplErr OTA_UpgradeGiveUp(uint16_t u16SeqId); Description \u2003\u2003Give up OTA upgrade Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16SeqId: OTA sequence number","title":"OTA_UpgradeGiveUp"},{"location":"api-reference/ota_apis.html#ota_triggerreboot","text":"Prototype T_OplErr OTA_TriggerReboot(uint16_t u16Delay); Description \u2003\u2003Reboot after OTA update successfully Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16Delay: delay timer (ms) to trgger reboot","title":"OTA_TriggerReboot"},{"location":"api-reference/wifi_apis.html","text":"WI-FI Network Manager Network Manager provide support for configuring and monitoring WI-FI networking functionality. We strongly recommend enabling network manager due to the rebust usage of Wi-Fi networking. Header File - quick_dev/app_ref/mngr_api/net_mngr_api.h API List - API Name APP_NmInit APP_NmInitAndCnct APP_NmEventProc APP_NmQuickCnctSetReq APP_NmWifiScanReq APP_NmWifiCnctReq Functions - APP_NmInit Prototype T_oplErr APP_NmInit(uint8_t u8AcEnable, T_NmUslctdCbFp fpUslctdCb) Description \u2003\u2003Network manager initiate function (optional to assign unsolicited callback) Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u8AcEnable: enable auto-connect \u2003\u2003fpUslctdCb: unsolicited callback function pointer APP_NmInitAndCnct Prototype T_OplErr APP_NmInitAndCnct(T_NmUslctdCbFp fpUslctdCb, T_NmWifiCnctConfig *ptNmWifiCnctConfig); Description \u2003\u2003Network manager initiate function and trigger WI-FI connect direclty Info optional to assign unsolicited callback Info SSID & PWD connection only, and will clear all profile record only store the assigned one Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003fpUslctdCb: unsolicited callback function pointer \u2003\u2003ptNmWifiCnctConfig: WI-FI connect config APP_NmEventProc Prototype T_OplErr APP_NmEventProc(uint32_t u32EventId, uint8_t *u8Data, uint32_t u32DataLen); Description \u2003\u2003Network manager event process (context in app_main, should runs in app_main task) Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u32EventId: network manager event ID \u2003\u2003u8Data: data send to network manager \u2003\u2003data lens send to network manager APP_NmQuickCnctSetReq Prototype T_OplErr APP_NmQuickCnctSetReq(T_NmWifiQCnctSet *ptNmWifiQCnctSet, T_NmQCnctSetIndCbFp fpIndCb); Description \u2003\u2003Trigger Wi-Fi quick connect set request, that is insert AP profile and enable auto Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003 fpIndCb: indicate callback function pointer (if required) APP_NmWifiScanReq Prototype T_OplErr APP_NmWifiScanReq(T_NmScanDoneIndCbFp fpIndCb); Description \u2003\u2003Trigger WI-FI scan request, and carried the scan result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003fpIndCb: indicate callback function pointer (if required) APP_NmWifiCnctReq Prototype T_OplErr APP_NmWifiCnctReq(T_NmWifiCnctConfig *ptNmWifiCnctConfig, T_NmCnctIndCbFp fpIndCb); Description \u2003\u2003Trigger WI-FI connect request, and carried the connect result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003ptWmWifiCnctConfig: WI-FI connect configuration \u2003\u2003fpIndCb: indicate callback function pointer (if required) WI-FI Manager Header File - quick_dev/app_ref/mngr_api/wifi_mngr_api.h API List - API Name Opl_Wifi_Init_Req Opl_Wifi_Scan_Req Opl_Wifi_Conn_Req Opl_Wifi_Disc_Req Opl_Wifi_Uslctd_CB_Reg Opl_Wifi_AC_Enable_Req Opl_Wifi_AC_Disable_Req Opl_Wifi_Profile_Ins Opl_Wifi_Profile_Get Opl_Wifi_Profile_Clear Opl_Wifi_ApInfo_Get Opl_Wifi_MacAddr_Get Opl_Wifi_ManufName_Get Opl_Wifi_ConfigSource_Get Opl_Wifi_Rssi_Get Opl_Wifi_ApNum_Get Opl_Wifi_ApRecord_Get Opl_Wifi_AutoConnectApNum_Get Opl_Wifi_AutoConnectApInfo_Get Opl_Wifi_AutoConnectListNum_Get Opl_Wifi_ScanList_Get Opl_Wifi_MacAddr_Set Opl_Wifi_ManufName_Set Opl_Wifi_ConfigSource_Set Opl_Wifi_Skip_Dtim_Module_Reg Opl_Wifi_Skip_Dtim_Set Functions - Opl_Wifi_Init_Req Prototype T_OplErr Opl_Wifi_Init_Req(T_WaInitDoneIndCbFp fpIndCb); Description \u2003\u2003WI-FI manager initiate function, and carried the init result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003fpUslctdCb: unsolicited callback function pointer Opl_Wifi_Scan_Req Prototype T_OplErr Opl_Wifi_Scan_Req(wifi_scan_config_t *ptWifiScanConfig, T_WaScanDoneIndCbFp fpIndCb); Description \u2003\u2003Trigger WI-FI scan request, and carried the scan result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003ptWifiScanConfig: scan config structure \u2003\u2003fpIndCb: indicate callback function pointer (if required) Opl_Wifi_Conn_Req Prototype T_OplErr Opl_Wifi_Conn_Req(T_WmConnConfig *ptWifiConnConfig, T_WaConnectIndCbFp fpIndCb); Description \u2003\u2003Trigger WI-FI connect request, and carried the connect result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003ptWifiConnConfig: connect config structure \u2003\u2003fpIndCb: indicate callback function pointer (if required) Opl_Wifi_Disc_Req Prototype T_OplErr Opl_Wifi_Disc_Req(T_WaDisconnectIndCbFp fpIndCb); Description \u2003\u2003Trigger WI-FI disconnect request, and carried the disconnect result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003fpIndCb: indicate callback function pointer (if required) Opl_Wifi_Uslctd_CB_Reg Prototype T_OplErr Opl_Wifi_Uslctd_CB_Reg(T_WmUslctedCbFp fpUslctdCb); Description \u2003\u2003Register unsolicited callback for WI-FI manager Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003indicate callback function pointer (if required) Opl_Wifi_AC_Enable_Req Prototype T_OplErr Opl_Wifi_AC_Enable_Req(T_AcEnableIndCbFp fpIndCb); Description \u2003\u2003Enable auto-connect request, and carried the enable result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003fpIndCb: indicate callback function pointer (if required) Opl_Wifi_AC_Disable_Req Prototype T_OplErr Opl_Wifi_AC_Disable_Req(bool blActDisconnect, T_AcDisableIndCbFp fpIndCb); Description \u2003\u2003Disable auto-connect request, and carried the disabled result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003blActDisconnect: \u2003\u2003\u2003\u2003true -> will do WI-FI disconnect while disable auto-connect \u2003\u2003\u2003\u2003false -> will not do WI-FI disconnect while disable auto-connect \u2003\u2003fpIndCb: indicate callback function pointer (if required) Opl_Wifi_Profile_Ins Prototype void Opl_Wifi_Profile_Ins(T_PrApProfile tNewProfile); Description \u2003\u2003Insert WI-FI AP information into AP profile list Return \u2003\u2003None Parameters \u2003\u2003tNewProfile: AP information structure Opl_Wifi_Profile_Get Prototype T_PrApProfilePtr Opl_Wifi_Profile_Get(void); Description \u2003\u2003Get WI-FI AP profile list Return \u2003\u2003AP profile list Parameters \u2003\u2003None Opl_Wifi_Profile_Clear Prototype void Opl_Wifi_Profile_Clear(void); Description \u2003\u2003Clear WI-FI AP profile list Return \u2003\u2003None Parameters \u2003\u2003None Opl_Wifi_ApInfo_Get Prototype T_OplErr Opl_Wifi_ApInfo_Get(wifi_ap_record_t *ptApRecord); Description \u2003\u2003Get WI-FI AP information Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003ptApRecord: AP information Opl_Wifi_MacAddr_Get Prototype T_OplErr Opl_Wifi_MacAddr_Get(uint8_t *pu8Address); Description \u2003\u2003Get WI-FI mac address Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pu8Address: WI-FI mac address Opl_Wifi_ManufName_Get Prototype T_OplErr Opl_Wifi_ManufName_Get(uint8_t *pu8Name); Description \u2003\u2003Get manufacturer name Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003 pu8Name: manufacturer name Opl_Wifi_ConfigSource_Get Prototype T_OplErr Opl_Wifi_ConfigSource_Get(T_WmWifiGetConfigSource *tWmWifiGetConfigSource); Description \u2003\u2003Get configure source Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003tWmWifiGetConfigSource: configure source structure Opl_Wifi_Rssi_Get Prototype T_OplErr Opl_Wifi_Rssi_Get(int8_t *pi8Rssi); Description \u2003\u2003Get current rssi value Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pi8Rssi: rssi value Opl_Wifi_ApNum_Get Prototype T_OplErr Opl_Wifi_ApNum_Get(uint16_t *pu16ApCount, wifi_scan_info_t *ptScanInfo); Description \u2003\u2003Get AP scanned number Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pu16ApCount: count number of AP \u2003\u2003ptScanInfo: sacn information structure Opl_Wifi_ApRecord_Get Prototype T_OplErr Opl_Wifi_ApRecord_Get(uint16_t *pu16ApCount, wifi_scan_info_t *ptScanInfo); Description \u2003\u2003Get AP record Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pu16ApCount: count number of AP \u2003\u2003ptScanInfo: sacn information structure Opl_Wifi_AutoConnectApNum_Get Prototype T_OplErr Opl_Wifi_AutoConnectApNum_Get(uint8_t *pu8Num); Description \u2003\u2003Get auto-connect AP number Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003Pu8Num: auto-connect AP number Opl_Wifi_AutoConnectApInfo_Get Prototype T_OplErr Opl_Wifi_AutoConnectApInfo_Get(uint8_t u8Index, wifi_auto_connect_info_t *ptAutoConnInfo); Description \u2003\u2003Get specific auto-connect AP information Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u8Index: index of auto-connect list \u2003\u2003ptAutoConnInfo: auto-connect AP information structure Opl_Wifi_AutoConnectListNum_Get Prototype T_OplErr Opl_Wifi_AutoConnectListNum_Get(uint8_t *pu8Num); Description \u2003\u2003Get auto-connect list number Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003Pu8Num: auto-connect list number Opl_Wifi_ScanList_Get Prototype T_OplErr Opl_Wifi_ScanList_Get(wifi_scan_list_t *ptScanList); Description \u2003\u2003Get scan list result Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003ptScanList: scan list structure Opl_Wifi_MacAddr_Set Prototype T_OplErr Opl_Wifi_MacAddr_Set(uint8_t *pu8Address); Description \u2003\u2003Set Wi-Fi mac address Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pu8Address: WI-FI mac address Opl_Wifi_ManufName_Set Prototype T_OplErr Opl_Wifi_ManufName_Set(uint8_t *pu8Name); Description \u2003\u2003Set manufacturer name Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003tWmWifiSetConfigSource: configure source structure Opl_Wifi_ConfigSource_Set Prototype T_OplErr Opl_Wifi_ConfigSource_Set(T_WmWifiSetConfigSource *tWmWifiSetConfigSource); Description \u2003\u2003Set configure sourse Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003tWmWifiSetConfigSource: configure source structure Opl_Wifi_Skip_Dtim_Module_Reg Prototype T_OplErr Opl_Wifi_Skip_Dtim_Module_Reg(uint16_t *u16ModuleId); Description \u2003\u2003Resgister skip DTIM module Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16ModuleId: skip DTIM module ID Opl_Wifi_Skip_Dtim_Set Prototype T_OplErr Opl_Wifi_Skip_Dtim_Set(uint16_t u16ModuleId, uint8_t u8Enable); Description \u2003\u2003Set skip DTIM Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16ModuleId: registed skip DTIM module ID Info must reigster by calling Opl_Wifi_Skip_Dtim_Module_Reg first \u2003\u2003u8Enable: true -> skip DTIM, false -> no skip DTIM","title":"WI-FI"},{"location":"api-reference/wifi_apis.html#wi-fi","text":"","title":"WI-FI"},{"location":"api-reference/wifi_apis.html#network-manager","text":"Network Manager provide support for configuring and monitoring WI-FI networking functionality. We strongly recommend enabling network manager due to the rebust usage of Wi-Fi networking.","title":"Network Manager"},{"location":"api-reference/wifi_apis.html#header-file-","text":"quick_dev/app_ref/mngr_api/net_mngr_api.h","title":"Header File -"},{"location":"api-reference/wifi_apis.html#api-list-","text":"API Name APP_NmInit APP_NmInitAndCnct APP_NmEventProc APP_NmQuickCnctSetReq APP_NmWifiScanReq APP_NmWifiCnctReq","title":"API List -"},{"location":"api-reference/wifi_apis.html#functions-","text":"","title":"Functions -"},{"location":"api-reference/wifi_apis.html#app_nminit","text":"Prototype T_oplErr APP_NmInit(uint8_t u8AcEnable, T_NmUslctdCbFp fpUslctdCb) Description \u2003\u2003Network manager initiate function (optional to assign unsolicited callback) Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u8AcEnable: enable auto-connect \u2003\u2003fpUslctdCb: unsolicited callback function pointer","title":"APP_NmInit"},{"location":"api-reference/wifi_apis.html#app_nminitandcnct","text":"Prototype T_OplErr APP_NmInitAndCnct(T_NmUslctdCbFp fpUslctdCb, T_NmWifiCnctConfig *ptNmWifiCnctConfig); Description \u2003\u2003Network manager initiate function and trigger WI-FI connect direclty Info optional to assign unsolicited callback Info SSID & PWD connection only, and will clear all profile record only store the assigned one Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003fpUslctdCb: unsolicited callback function pointer \u2003\u2003ptNmWifiCnctConfig: WI-FI connect config","title":"APP_NmInitAndCnct"},{"location":"api-reference/wifi_apis.html#app_nmeventproc","text":"Prototype T_OplErr APP_NmEventProc(uint32_t u32EventId, uint8_t *u8Data, uint32_t u32DataLen); Description \u2003\u2003Network manager event process (context in app_main, should runs in app_main task) Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u32EventId: network manager event ID \u2003\u2003u8Data: data send to network manager \u2003\u2003data lens send to network manager","title":"APP_NmEventProc"},{"location":"api-reference/wifi_apis.html#app_nmquickcnctsetreq","text":"Prototype T_OplErr APP_NmQuickCnctSetReq(T_NmWifiQCnctSet *ptNmWifiQCnctSet, T_NmQCnctSetIndCbFp fpIndCb); Description \u2003\u2003Trigger Wi-Fi quick connect set request, that is insert AP profile and enable auto Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003 fpIndCb: indicate callback function pointer (if required)","title":"APP_NmQuickCnctSetReq"},{"location":"api-reference/wifi_apis.html#app_nmwifiscanreq","text":"Prototype T_OplErr APP_NmWifiScanReq(T_NmScanDoneIndCbFp fpIndCb); Description \u2003\u2003Trigger WI-FI scan request, and carried the scan result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003fpIndCb: indicate callback function pointer (if required)","title":"APP_NmWifiScanReq"},{"location":"api-reference/wifi_apis.html#app_nmwificnctreq","text":"Prototype T_OplErr APP_NmWifiCnctReq(T_NmWifiCnctConfig *ptNmWifiCnctConfig, T_NmCnctIndCbFp fpIndCb); Description \u2003\u2003Trigger WI-FI connect request, and carried the connect result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003ptWmWifiCnctConfig: WI-FI connect configuration \u2003\u2003fpIndCb: indicate callback function pointer (if required)","title":"APP_NmWifiCnctReq"},{"location":"api-reference/wifi_apis.html#wi-fi-manager","text":"","title":"WI-FI Manager"},{"location":"api-reference/wifi_apis.html#header-file-_1","text":"quick_dev/app_ref/mngr_api/wifi_mngr_api.h","title":"Header File -"},{"location":"api-reference/wifi_apis.html#api-list-_1","text":"API Name Opl_Wifi_Init_Req Opl_Wifi_Scan_Req Opl_Wifi_Conn_Req Opl_Wifi_Disc_Req Opl_Wifi_Uslctd_CB_Reg Opl_Wifi_AC_Enable_Req Opl_Wifi_AC_Disable_Req Opl_Wifi_Profile_Ins Opl_Wifi_Profile_Get Opl_Wifi_Profile_Clear Opl_Wifi_ApInfo_Get Opl_Wifi_MacAddr_Get Opl_Wifi_ManufName_Get Opl_Wifi_ConfigSource_Get Opl_Wifi_Rssi_Get Opl_Wifi_ApNum_Get Opl_Wifi_ApRecord_Get Opl_Wifi_AutoConnectApNum_Get Opl_Wifi_AutoConnectApInfo_Get Opl_Wifi_AutoConnectListNum_Get Opl_Wifi_ScanList_Get Opl_Wifi_MacAddr_Set Opl_Wifi_ManufName_Set Opl_Wifi_ConfigSource_Set Opl_Wifi_Skip_Dtim_Module_Reg Opl_Wifi_Skip_Dtim_Set","title":"API List -"},{"location":"api-reference/wifi_apis.html#functions-_1","text":"","title":"Functions -"},{"location":"api-reference/wifi_apis.html#opl_wifi_init_req","text":"Prototype T_OplErr Opl_Wifi_Init_Req(T_WaInitDoneIndCbFp fpIndCb); Description \u2003\u2003WI-FI manager initiate function, and carried the init result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003fpUslctdCb: unsolicited callback function pointer","title":"Opl_Wifi_Init_Req"},{"location":"api-reference/wifi_apis.html#opl_wifi_scan_req","text":"Prototype T_OplErr Opl_Wifi_Scan_Req(wifi_scan_config_t *ptWifiScanConfig, T_WaScanDoneIndCbFp fpIndCb); Description \u2003\u2003Trigger WI-FI scan request, and carried the scan result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003ptWifiScanConfig: scan config structure \u2003\u2003fpIndCb: indicate callback function pointer (if required)","title":"Opl_Wifi_Scan_Req"},{"location":"api-reference/wifi_apis.html#opl_wifi_conn_req","text":"Prototype T_OplErr Opl_Wifi_Conn_Req(T_WmConnConfig *ptWifiConnConfig, T_WaConnectIndCbFp fpIndCb); Description \u2003\u2003Trigger WI-FI connect request, and carried the connect result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003ptWifiConnConfig: connect config structure \u2003\u2003fpIndCb: indicate callback function pointer (if required)","title":"Opl_Wifi_Conn_Req"},{"location":"api-reference/wifi_apis.html#opl_wifi_disc_req","text":"Prototype T_OplErr Opl_Wifi_Disc_Req(T_WaDisconnectIndCbFp fpIndCb); Description \u2003\u2003Trigger WI-FI disconnect request, and carried the disconnect result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003fpIndCb: indicate callback function pointer (if required)","title":"Opl_Wifi_Disc_Req"},{"location":"api-reference/wifi_apis.html#opl_wifi_uslctd_cb_reg","text":"Prototype T_OplErr Opl_Wifi_Uslctd_CB_Reg(T_WmUslctedCbFp fpUslctdCb); Description \u2003\u2003Register unsolicited callback for WI-FI manager Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003indicate callback function pointer (if required)","title":"Opl_Wifi_Uslctd_CB_Reg"},{"location":"api-reference/wifi_apis.html#opl_wifi_ac_enable_req","text":"Prototype T_OplErr Opl_Wifi_AC_Enable_Req(T_AcEnableIndCbFp fpIndCb); Description \u2003\u2003Enable auto-connect request, and carried the enable result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003fpIndCb: indicate callback function pointer (if required)","title":"Opl_Wifi_AC_Enable_Req"},{"location":"api-reference/wifi_apis.html#opl_wifi_ac_disable_req","text":"Prototype T_OplErr Opl_Wifi_AC_Disable_Req(bool blActDisconnect, T_AcDisableIndCbFp fpIndCb); Description \u2003\u2003Disable auto-connect request, and carried the disabled result in indicate callback Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003blActDisconnect: \u2003\u2003\u2003\u2003true -> will do WI-FI disconnect while disable auto-connect \u2003\u2003\u2003\u2003false -> will not do WI-FI disconnect while disable auto-connect \u2003\u2003fpIndCb: indicate callback function pointer (if required)","title":"Opl_Wifi_AC_Disable_Req"},{"location":"api-reference/wifi_apis.html#opl_wifi_profile_ins","text":"Prototype void Opl_Wifi_Profile_Ins(T_PrApProfile tNewProfile); Description \u2003\u2003Insert WI-FI AP information into AP profile list Return \u2003\u2003None Parameters \u2003\u2003tNewProfile: AP information structure","title":"Opl_Wifi_Profile_Ins"},{"location":"api-reference/wifi_apis.html#opl_wifi_profile_get","text":"Prototype T_PrApProfilePtr Opl_Wifi_Profile_Get(void); Description \u2003\u2003Get WI-FI AP profile list Return \u2003\u2003AP profile list Parameters \u2003\u2003None","title":"Opl_Wifi_Profile_Get"},{"location":"api-reference/wifi_apis.html#opl_wifi_profile_clear","text":"Prototype void Opl_Wifi_Profile_Clear(void); Description \u2003\u2003Clear WI-FI AP profile list Return \u2003\u2003None Parameters \u2003\u2003None","title":"Opl_Wifi_Profile_Clear"},{"location":"api-reference/wifi_apis.html#opl_wifi_apinfo_get","text":"Prototype T_OplErr Opl_Wifi_ApInfo_Get(wifi_ap_record_t *ptApRecord); Description \u2003\u2003Get WI-FI AP information Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003ptApRecord: AP information","title":"Opl_Wifi_ApInfo_Get"},{"location":"api-reference/wifi_apis.html#opl_wifi_macaddr_get","text":"Prototype T_OplErr Opl_Wifi_MacAddr_Get(uint8_t *pu8Address); Description \u2003\u2003Get WI-FI mac address Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pu8Address: WI-FI mac address","title":"Opl_Wifi_MacAddr_Get"},{"location":"api-reference/wifi_apis.html#opl_wifi_manufname_get","text":"Prototype T_OplErr Opl_Wifi_ManufName_Get(uint8_t *pu8Name); Description \u2003\u2003Get manufacturer name Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003 pu8Name: manufacturer name","title":"Opl_Wifi_ManufName_Get"},{"location":"api-reference/wifi_apis.html#opl_wifi_configsource_get","text":"Prototype T_OplErr Opl_Wifi_ConfigSource_Get(T_WmWifiGetConfigSource *tWmWifiGetConfigSource); Description \u2003\u2003Get configure source Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003tWmWifiGetConfigSource: configure source structure","title":"Opl_Wifi_ConfigSource_Get"},{"location":"api-reference/wifi_apis.html#opl_wifi_rssi_get","text":"Prototype T_OplErr Opl_Wifi_Rssi_Get(int8_t *pi8Rssi); Description \u2003\u2003Get current rssi value Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pi8Rssi: rssi value","title":"Opl_Wifi_Rssi_Get"},{"location":"api-reference/wifi_apis.html#opl_wifi_apnum_get","text":"Prototype T_OplErr Opl_Wifi_ApNum_Get(uint16_t *pu16ApCount, wifi_scan_info_t *ptScanInfo); Description \u2003\u2003Get AP scanned number Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pu16ApCount: count number of AP \u2003\u2003ptScanInfo: sacn information structure","title":"Opl_Wifi_ApNum_Get"},{"location":"api-reference/wifi_apis.html#opl_wifi_aprecord_get","text":"Prototype T_OplErr Opl_Wifi_ApRecord_Get(uint16_t *pu16ApCount, wifi_scan_info_t *ptScanInfo); Description \u2003\u2003Get AP record Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pu16ApCount: count number of AP \u2003\u2003ptScanInfo: sacn information structure","title":"Opl_Wifi_ApRecord_Get"},{"location":"api-reference/wifi_apis.html#opl_wifi_autoconnectapnum_get","text":"Prototype T_OplErr Opl_Wifi_AutoConnectApNum_Get(uint8_t *pu8Num); Description \u2003\u2003Get auto-connect AP number Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003Pu8Num: auto-connect AP number","title":"Opl_Wifi_AutoConnectApNum_Get"},{"location":"api-reference/wifi_apis.html#opl_wifi_autoconnectapinfo_get","text":"Prototype T_OplErr Opl_Wifi_AutoConnectApInfo_Get(uint8_t u8Index, wifi_auto_connect_info_t *ptAutoConnInfo); Description \u2003\u2003Get specific auto-connect AP information Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u8Index: index of auto-connect list \u2003\u2003ptAutoConnInfo: auto-connect AP information structure","title":"Opl_Wifi_AutoConnectApInfo_Get"},{"location":"api-reference/wifi_apis.html#opl_wifi_autoconnectlistnum_get","text":"Prototype T_OplErr Opl_Wifi_AutoConnectListNum_Get(uint8_t *pu8Num); Description \u2003\u2003Get auto-connect list number Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003Pu8Num: auto-connect list number","title":"Opl_Wifi_AutoConnectListNum_Get"},{"location":"api-reference/wifi_apis.html#opl_wifi_scanlist_get","text":"Prototype T_OplErr Opl_Wifi_ScanList_Get(wifi_scan_list_t *ptScanList); Description \u2003\u2003Get scan list result Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003ptScanList: scan list structure","title":"Opl_Wifi_ScanList_Get"},{"location":"api-reference/wifi_apis.html#opl_wifi_macaddr_set","text":"Prototype T_OplErr Opl_Wifi_MacAddr_Set(uint8_t *pu8Address); Description \u2003\u2003Set Wi-Fi mac address Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003pu8Address: WI-FI mac address","title":"Opl_Wifi_MacAddr_Set"},{"location":"api-reference/wifi_apis.html#opl_wifi_manufname_set","text":"Prototype T_OplErr Opl_Wifi_ManufName_Set(uint8_t *pu8Name); Description \u2003\u2003Set manufacturer name Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003tWmWifiSetConfigSource: configure source structure","title":"Opl_Wifi_ManufName_Set"},{"location":"api-reference/wifi_apis.html#opl_wifi_configsource_set","text":"Prototype T_OplErr Opl_Wifi_ConfigSource_Set(T_WmWifiSetConfigSource *tWmWifiSetConfigSource); Description \u2003\u2003Set configure sourse Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003tWmWifiSetConfigSource: configure source structure","title":"Opl_Wifi_ConfigSource_Set"},{"location":"api-reference/wifi_apis.html#opl_wifi_skip_dtim_module_reg","text":"Prototype T_OplErr Opl_Wifi_Skip_Dtim_Module_Reg(uint16_t *u16ModuleId); Description \u2003\u2003Resgister skip DTIM module Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16ModuleId: skip DTIM module ID","title":"Opl_Wifi_Skip_Dtim_Module_Reg"},{"location":"api-reference/wifi_apis.html#opl_wifi_skip_dtim_set","text":"Prototype T_OplErr Opl_Wifi_Skip_Dtim_Set(uint16_t u16ModuleId, uint8_t u8Enable); Description \u2003\u2003Set skip DTIM Return \u2003\u2003Reference to opl_err Parameters \u2003\u2003u16ModuleId: registed skip DTIM module ID Info must reigster by calling Opl_Wifi_Skip_Dtim_Module_Reg first \u2003\u2003u8Enable: true -> skip DTIM, false -> no skip DTIM","title":"Opl_Wifi_Skip_Dtim_Set"},{"location":"application-guide/ble.html","text":"BluetoothLE BLE Manager BLE manager provide the auto-advertise option and handling the BLE status that make user eaiser to control BLE statment. Initialize Before using the BLE manager, please follow below steps to initiate. Step 1. Enable BLE manager #define BM_ENABLED (1) The definition been defined in qd_module.h in sys_config folder. Step 2. Add related file in Keil project Step 3. Register callback and init Add below program in app_main.c void APP_BleUnsolicitedCallback(uint16_t u16EvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { switch(u16EvtType) { case USLCTED_CB_EVT_BLE_INIT: { // ble inited event // initialize ble advertise data APP_BleAdvDataInit(); // initialize ble scan response data APP_BleScanRspDataInit(); break; } case USLCTED_CB_EVT_BLE_ENT_ADVERTISE: { // enter advertising event break; } case USLCTED_CB_EVT_BLE_EXI_ADVERTISE: { // exit advertising event break; } case USLCTED_CB_EVT_BLE_CONNECTED: { // ble connected event break; } case USLCTED_CB_EVT_BLE_DISCONNECT: { // ble disconnect event break; } default: { // should not be here break; } } } void APP_BleInit(void) { // assign unsolicited callback function Opl_Ble_Uslctd_CB_Reg(&APP_BleUnsolicitedCallback); // register service GAP_Svc_Init(); GATT_Svc_Init(); // ...register your service here // initialize the ble manager (auto-adv) Opl_Ble_Init_Req(true); // user implement } The parameter of Opl_Ble_Init_Req() is to enable/disable auto-advertise function. If set as true - the auto-advertise will be enabled, and will directly start advertise after ble manager init done. While disconnect from connected state, ble manager will also start advertising, till user calling Opl_Ble_Stop_Req() . If set as false - the auto-advertise will be disabled, and will not advertise after ble manager init done. Info The APP_BleInit() function create by default in app_main.c , it's for developer to fill the ble related init function in it. Step 4. Setup advertise data void APP_BleAdvDataInit(void) { // ble advertise data inititate // user modify // * uint8_t au8BleAdvertData[]; // configure your own advertise data Opl_Ble_Advertise_Data_Set(au8BleAdvertData, lens); // * } Step 5. Setup scan response data Create scan response data init function, and modify your wishes data. void APP_BleScanRspDataInit(void) { // ble scan response data inititate // user modify // * uint8_t au8BleScanRspData[BLE_ADV_SCAN_BUF_SIZE]; // configure your own scan response data if(OPL_OK != Opl_Ble_ScanRsp_Data_Set(au8BleScanRspData, lens)) { OPL_LOG_ERRO(APP, \"Scan Rsp Data Set Fail\"); } // * } Step 6. Call set adv data & scan rsp data after init Call APP_BleAdvDataInit (created in step 4) and APP_BleScanRspDataInit (created in step 5) after recevied USLCTED_CB_EVT_BLE_INIT event in ble unsolicited callback. void APP_BleUnsolicitedCallback(uint16_t u16EvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { switch(u16EvtType) { case USLCTED_CB_EVT_BLE_INIT: { // ble inited event // initialize ble advertise data APP_BleAdvDataInit(); // <--- // initialize ble scan response data APP_BleScanRspDataInit(); // <--- break; } Unsolicited callback The unsolicited callback will content with ble status and carried the result in each state. Info Unsolicited callback prototype located in ble_mngr_api.h How To... BLE Manager The BLE manager should provide a mechanism for user BLE data processing application to register the user (vendor defined) service table. The user data processing application process the data receive from and transmit to the phone App via BLE. Developer could set a file for specific service in quick_dev\\ble_services How to create BLE service BLE service initiate (e.g. Battery Service) void BAS_Svc_Init(void) { g_tBasSvcHandle.patSvcDb = g_BasSvcDb; g_tBasSvcHandle.u8SvcDbSize = BAS_SVC_IDX_TOTAL; g_tBasSvcHandle.ptSvcGattDispatchHandler = BAS_Svc_GattDispatchHandler; if(OPL_OK != Opl_Ble_Service_Assign(&g_tBasSvcHandle)) { OPL_LOG_ERRO(BAS, \"BAS Service assign fail\\r\\n\"); } } g_tBasSvcHandle is the BLE service handle structure static T_BmSvcHandle g_tBasSvcHandle = {0}; typedef struct S_BmSvcHandle { LE_GATT_SERVICE_T *ptSvcDef; LE_GATT_ATTR_T *patSvcDb; uint8_t u8SvcDbSize; uint8_t u8Reserved; uint16_t u16SvcDataEvtBase; uint16_t u16SvcDataEvtTop; T_BmSvcDataProcessHandlerFp ptSvcDataProcessHandler; T_BmSvcGattDispatchHandlerFp ptSvcGattDispatchHandler; } T_BmSvcHandle; Developer at least should set three parameters *patSvcDb , u8SvcDbSize and ptSvcGattDispatchHandler . *patSvcDb is the service attribute information. u8SvcDbSize is the service size and ptSvcGattDispatchHandler is GATT dispatch handler. LE_GATT_ATTR_T *patSvcDb; typedef struct { UINT16 handle; /**< handle */ UINT8 format; /**< UUID type */ UINT16 * const pUuid; /**< UUID */ UINT16 permit; /**< permit */ UINT16 maxLen; /**< maxinum value length */ UINT16 len; /**< value length */ UINT8 * const pVal; /**< value */ } LE_GATT_ATTR_T; After configurating the BLE handle structure, developer could register BLE service via BLE Manager. Register BLE service via BLE Manager T_OplErr Opl_Ble_Service_Assign(T_BmSvcHandle *ptBmSvcHandle) How to receive/notify data via BLE Developer could create user defined service to implement input/output via BLE. Receive data via BLE In user defined servcie, developer can use user defined GATT dispatch handler to handle data from LE task. The developer can create different handlers for processing according to the type of data received in user defined GATT dispatch handler. static T_OplErr UD_Svc_GattDispatchHandler(MESSAGEID tId, MESSAGE tMsg) { switch(tId) { case LE_GATT_MSG_ACCESS_READ_IND: { UD_Svc_GattDispatchReadHandler((LE_GATT_MSG_ACCESS_READ_IND_T *)tMsg); break; } case LE_GATT_MSG_ACCESS_WRITE_IND: { UD_Svc_GattDispatchWriteHandler((LE_GATT_MSG_ACCESS_WRITE_IND_T *)tMsg); break; } case LE_GATT_MSG_NOTIFY_CFM: { OPL_LOG_INFO(UDS, \"Notify Confirm\"); break; } default: { return OPL_ERR_CASE_INVALID; } } return OPL_OK; } There are three types of events in user defined handler that incude LE_GATT_MSG_ACCESS_READ_IND , LE_GATT_MSG_ACCESS_WRITE_IND and LE_GATT_MSG_NOTIFY_CFM . Developer could create different handler to handle these events. If receiving LE_GATT_MSG_ACCESS_WRITE_IND , developer could create write handler (e.g. UD_Svc_GattDispatchWriteHandler ). In this handler, develop must response read access to bottom layer via LE LeGattAccessWriteRsp . static void UD_Svc_GattDispatchWriteHandler(LE_GATT_MSG_ACCESS_WRITE_IND_T *ind) { // process the write access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tUdSvcHandle.ptSvcDef->startHdl; // printf(\"UD Svc attId = %d op = %x offset = %d\\r\\n\", u16AttrId, ind->flag, ind->offset); switch(u16AttrId) { case UD_SVC_IDX_TX_VAL: { // send message to app APP_SendMessage(APP_EVT_BLE_DATA_IND, ind->pVal, ind->len); break; } case UD_SVC_IDX_RX_CFG: { uint16_t u16Enable = *((uint16_t *)ind->pVal); if ((ind->len == 2) && (u16Enable <= 1)) { LeGattChangeAttrVal(g_tUdSvcHandle.ptSvcDef, UD_SVC_IDX_RX_CFG, sizeof(u16Enable), &u16Enable); } else { u8AttErr = LE_ATT_ERR_INVALID_ATTR_VALUE_LEN; } break; } default: { u8AttErr = LE_ATT_ERR_WRITE_NOT_PERMITTED; break; } } LeGattAccessWriteRsp(ind->conn_hdl, ind->flag, ind->handle, u8AttErr); } If receiving LE_GATT_MSG_ACCESS_READ_IND , developer could create read handler (e.g. UD_Svc_GattDispatchReadHandler ). In this handler, develop must response read access to bottom layer via LE LeGattAccessReadRsp . static void UD_Svc_GattDispatchReadHandler(LE_GATT_MSG_ACCESS_READ_IND_T *ind) { // process the read access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tUdSvcHandle.ptSvcDef->startHdl; // printf(\"UD Svc attId = %d op = %x offset = %d\\r\\n\", u16AttrId, ind->flag, ind->offset); switch(u16AttrId) { case UD_SVC_IDX_RX_VAL: case UD_SVC_IDX_RX_CFG: { break; } default: { u8AttErr = LE_ATT_ERR_READ_NOT_PERMITTED; break; } } LeGattAccessReadRsp(ind->conn_hdl, ind->handle, u8AttErr); } Notify data via BLE If wanting to actively send messages from application to the host via BLE, developer can create a notify function (e.g. UD_Svc_RxDataOutNotify ) in the user defined service. LeGattCharValNotify can send data via LE. T_OplErr UD_Svc_RxDataOutNotify(uint8_t *pu8Data, uint32_t u32DataLen) { LE_ERR_STATE status; uint16_t u16NotiAttrId = g_tUdSvcHandle.ptSvcDef->startHdl + UD_SVC_IDX_RX_VAL; // update rx data to attribute value LeGattChangeAttrVal(g_tUdSvcHandle.ptSvcDef, (uint16_t)UD_SVC_IDX_RX_VAL, u32DataLen, pu8Data); // notify rx data to host status = LeGattCharValNotify(Opl_Ble_EntityGet()->conn_hdl, u16NotiAttrId, u32DataLen, pu8Data); if (status != SYS_ERR_SUCCESS) { OPL_LOG_ERRO(BAS, \"Ble sending data fail\"); return OPL_ERR; } return OPL_OK; } How to perform BLE process Start BLE advertising T_OplErr Opl_Ble_Start_Req(uint8_t u8AutoAdvEn) To start BLE advertising, *u8AutoAdvEn is true that enable auto-advertise while disconnect. Stop BLE advertisng T_OplErr Opl_Ble_Stop_Req(void) Set BLE advertise data T_OplErr Opl_Ble_Advertise_Data_Set(uint8_t *pau8AdvData, uint8_t u8AdvDataLen) If wanting to set BLE advertisement data via BLE Manager, developer could config BLE data *pau8AdvData in Opl_Ble_Advertise_Data_Set Set BLE scan respnse data T_OplErr Opl_Ble_ScanRsp_Data_Set(uint8_t *pau8ScanRspData, uint8_t u8ScanRspDataLen) If BLE central scan, developer could set scan response data in BLE perpherial","title":"BluetoothLE"},{"location":"application-guide/ble.html#bluetoothle","text":"","title":"BluetoothLE"},{"location":"application-guide/ble.html#ble-manager","text":"BLE manager provide the auto-advertise option and handling the BLE status that make user eaiser to control BLE statment.","title":"BLE Manager"},{"location":"application-guide/ble.html#initialize","text":"Before using the BLE manager, please follow below steps to initiate.","title":"Initialize"},{"location":"application-guide/ble.html#step-1-enable-ble-manager","text":"#define BM_ENABLED (1) The definition been defined in qd_module.h in sys_config folder.","title":"Step 1. Enable BLE manager"},{"location":"application-guide/ble.html#step-2-add-related-file-in-keil-project","text":"","title":"Step 2. Add related file in Keil project"},{"location":"application-guide/ble.html#step-3-register-callback-and-init","text":"Add below program in app_main.c void APP_BleUnsolicitedCallback(uint16_t u16EvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { switch(u16EvtType) { case USLCTED_CB_EVT_BLE_INIT: { // ble inited event // initialize ble advertise data APP_BleAdvDataInit(); // initialize ble scan response data APP_BleScanRspDataInit(); break; } case USLCTED_CB_EVT_BLE_ENT_ADVERTISE: { // enter advertising event break; } case USLCTED_CB_EVT_BLE_EXI_ADVERTISE: { // exit advertising event break; } case USLCTED_CB_EVT_BLE_CONNECTED: { // ble connected event break; } case USLCTED_CB_EVT_BLE_DISCONNECT: { // ble disconnect event break; } default: { // should not be here break; } } } void APP_BleInit(void) { // assign unsolicited callback function Opl_Ble_Uslctd_CB_Reg(&APP_BleUnsolicitedCallback); // register service GAP_Svc_Init(); GATT_Svc_Init(); // ...register your service here // initialize the ble manager (auto-adv) Opl_Ble_Init_Req(true); // user implement } The parameter of Opl_Ble_Init_Req() is to enable/disable auto-advertise function. If set as true - the auto-advertise will be enabled, and will directly start advertise after ble manager init done. While disconnect from connected state, ble manager will also start advertising, till user calling Opl_Ble_Stop_Req() . If set as false - the auto-advertise will be disabled, and will not advertise after ble manager init done. Info The APP_BleInit() function create by default in app_main.c , it's for developer to fill the ble related init function in it.","title":"Step 3. Register callback and init"},{"location":"application-guide/ble.html#step-4-setup-advertise-data","text":"void APP_BleAdvDataInit(void) { // ble advertise data inititate // user modify // * uint8_t au8BleAdvertData[]; // configure your own advertise data Opl_Ble_Advertise_Data_Set(au8BleAdvertData, lens); // * }","title":"Step 4. Setup advertise data"},{"location":"application-guide/ble.html#step-5-setup-scan-response-data","text":"Create scan response data init function, and modify your wishes data. void APP_BleScanRspDataInit(void) { // ble scan response data inititate // user modify // * uint8_t au8BleScanRspData[BLE_ADV_SCAN_BUF_SIZE]; // configure your own scan response data if(OPL_OK != Opl_Ble_ScanRsp_Data_Set(au8BleScanRspData, lens)) { OPL_LOG_ERRO(APP, \"Scan Rsp Data Set Fail\"); } // * }","title":"Step 5. Setup scan response data"},{"location":"application-guide/ble.html#step-6-call-set-adv-data-scan-rsp-data-after-init","text":"Call APP_BleAdvDataInit (created in step 4) and APP_BleScanRspDataInit (created in step 5) after recevied USLCTED_CB_EVT_BLE_INIT event in ble unsolicited callback. void APP_BleUnsolicitedCallback(uint16_t u16EvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { switch(u16EvtType) { case USLCTED_CB_EVT_BLE_INIT: { // ble inited event // initialize ble advertise data APP_BleAdvDataInit(); // <--- // initialize ble scan response data APP_BleScanRspDataInit(); // <--- break; }","title":"Step 6. Call set adv data &amp; scan rsp data after init"},{"location":"application-guide/ble.html#unsolicited-callback","text":"The unsolicited callback will content with ble status and carried the result in each state. Info Unsolicited callback prototype located in ble_mngr_api.h","title":"Unsolicited callback"},{"location":"application-guide/ble.html#how-to","text":"","title":"How To..."},{"location":"application-guide/ble.html#ble-manager_1","text":"The BLE manager should provide a mechanism for user BLE data processing application to register the user (vendor defined) service table. The user data processing application process the data receive from and transmit to the phone App via BLE. Developer could set a file for specific service in quick_dev\\ble_services","title":"BLE Manager"},{"location":"application-guide/ble.html#how-to-create-ble-service","text":"BLE service initiate (e.g. Battery Service) void BAS_Svc_Init(void) { g_tBasSvcHandle.patSvcDb = g_BasSvcDb; g_tBasSvcHandle.u8SvcDbSize = BAS_SVC_IDX_TOTAL; g_tBasSvcHandle.ptSvcGattDispatchHandler = BAS_Svc_GattDispatchHandler; if(OPL_OK != Opl_Ble_Service_Assign(&g_tBasSvcHandle)) { OPL_LOG_ERRO(BAS, \"BAS Service assign fail\\r\\n\"); } } g_tBasSvcHandle is the BLE service handle structure static T_BmSvcHandle g_tBasSvcHandle = {0}; typedef struct S_BmSvcHandle { LE_GATT_SERVICE_T *ptSvcDef; LE_GATT_ATTR_T *patSvcDb; uint8_t u8SvcDbSize; uint8_t u8Reserved; uint16_t u16SvcDataEvtBase; uint16_t u16SvcDataEvtTop; T_BmSvcDataProcessHandlerFp ptSvcDataProcessHandler; T_BmSvcGattDispatchHandlerFp ptSvcGattDispatchHandler; } T_BmSvcHandle; Developer at least should set three parameters *patSvcDb , u8SvcDbSize and ptSvcGattDispatchHandler . *patSvcDb is the service attribute information. u8SvcDbSize is the service size and ptSvcGattDispatchHandler is GATT dispatch handler. LE_GATT_ATTR_T *patSvcDb; typedef struct { UINT16 handle; /**< handle */ UINT8 format; /**< UUID type */ UINT16 * const pUuid; /**< UUID */ UINT16 permit; /**< permit */ UINT16 maxLen; /**< maxinum value length */ UINT16 len; /**< value length */ UINT8 * const pVal; /**< value */ } LE_GATT_ATTR_T; After configurating the BLE handle structure, developer could register BLE service via BLE Manager. Register BLE service via BLE Manager T_OplErr Opl_Ble_Service_Assign(T_BmSvcHandle *ptBmSvcHandle)","title":"How to create BLE service"},{"location":"application-guide/ble.html#how-to-receivenotify-data-via-ble","text":"Developer could create user defined service to implement input/output via BLE. Receive data via BLE In user defined servcie, developer can use user defined GATT dispatch handler to handle data from LE task. The developer can create different handlers for processing according to the type of data received in user defined GATT dispatch handler. static T_OplErr UD_Svc_GattDispatchHandler(MESSAGEID tId, MESSAGE tMsg) { switch(tId) { case LE_GATT_MSG_ACCESS_READ_IND: { UD_Svc_GattDispatchReadHandler((LE_GATT_MSG_ACCESS_READ_IND_T *)tMsg); break; } case LE_GATT_MSG_ACCESS_WRITE_IND: { UD_Svc_GattDispatchWriteHandler((LE_GATT_MSG_ACCESS_WRITE_IND_T *)tMsg); break; } case LE_GATT_MSG_NOTIFY_CFM: { OPL_LOG_INFO(UDS, \"Notify Confirm\"); break; } default: { return OPL_ERR_CASE_INVALID; } } return OPL_OK; } There are three types of events in user defined handler that incude LE_GATT_MSG_ACCESS_READ_IND , LE_GATT_MSG_ACCESS_WRITE_IND and LE_GATT_MSG_NOTIFY_CFM . Developer could create different handler to handle these events. If receiving LE_GATT_MSG_ACCESS_WRITE_IND , developer could create write handler (e.g. UD_Svc_GattDispatchWriteHandler ). In this handler, develop must response read access to bottom layer via LE LeGattAccessWriteRsp . static void UD_Svc_GattDispatchWriteHandler(LE_GATT_MSG_ACCESS_WRITE_IND_T *ind) { // process the write access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tUdSvcHandle.ptSvcDef->startHdl; // printf(\"UD Svc attId = %d op = %x offset = %d\\r\\n\", u16AttrId, ind->flag, ind->offset); switch(u16AttrId) { case UD_SVC_IDX_TX_VAL: { // send message to app APP_SendMessage(APP_EVT_BLE_DATA_IND, ind->pVal, ind->len); break; } case UD_SVC_IDX_RX_CFG: { uint16_t u16Enable = *((uint16_t *)ind->pVal); if ((ind->len == 2) && (u16Enable <= 1)) { LeGattChangeAttrVal(g_tUdSvcHandle.ptSvcDef, UD_SVC_IDX_RX_CFG, sizeof(u16Enable), &u16Enable); } else { u8AttErr = LE_ATT_ERR_INVALID_ATTR_VALUE_LEN; } break; } default: { u8AttErr = LE_ATT_ERR_WRITE_NOT_PERMITTED; break; } } LeGattAccessWriteRsp(ind->conn_hdl, ind->flag, ind->handle, u8AttErr); } If receiving LE_GATT_MSG_ACCESS_READ_IND , developer could create read handler (e.g. UD_Svc_GattDispatchReadHandler ). In this handler, develop must response read access to bottom layer via LE LeGattAccessReadRsp . static void UD_Svc_GattDispatchReadHandler(LE_GATT_MSG_ACCESS_READ_IND_T *ind) { // process the read access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tUdSvcHandle.ptSvcDef->startHdl; // printf(\"UD Svc attId = %d op = %x offset = %d\\r\\n\", u16AttrId, ind->flag, ind->offset); switch(u16AttrId) { case UD_SVC_IDX_RX_VAL: case UD_SVC_IDX_RX_CFG: { break; } default: { u8AttErr = LE_ATT_ERR_READ_NOT_PERMITTED; break; } } LeGattAccessReadRsp(ind->conn_hdl, ind->handle, u8AttErr); } Notify data via BLE If wanting to actively send messages from application to the host via BLE, developer can create a notify function (e.g. UD_Svc_RxDataOutNotify ) in the user defined service. LeGattCharValNotify can send data via LE. T_OplErr UD_Svc_RxDataOutNotify(uint8_t *pu8Data, uint32_t u32DataLen) { LE_ERR_STATE status; uint16_t u16NotiAttrId = g_tUdSvcHandle.ptSvcDef->startHdl + UD_SVC_IDX_RX_VAL; // update rx data to attribute value LeGattChangeAttrVal(g_tUdSvcHandle.ptSvcDef, (uint16_t)UD_SVC_IDX_RX_VAL, u32DataLen, pu8Data); // notify rx data to host status = LeGattCharValNotify(Opl_Ble_EntityGet()->conn_hdl, u16NotiAttrId, u32DataLen, pu8Data); if (status != SYS_ERR_SUCCESS) { OPL_LOG_ERRO(BAS, \"Ble sending data fail\"); return OPL_ERR; } return OPL_OK; }","title":"How to receive/notify data via BLE"},{"location":"application-guide/ble.html#how-to-perform-ble-process","text":"Start BLE advertising T_OplErr Opl_Ble_Start_Req(uint8_t u8AutoAdvEn) To start BLE advertising, *u8AutoAdvEn is true that enable auto-advertise while disconnect. Stop BLE advertisng T_OplErr Opl_Ble_Stop_Req(void) Set BLE advertise data T_OplErr Opl_Ble_Advertise_Data_Set(uint8_t *pau8AdvData, uint8_t u8AdvDataLen) If wanting to set BLE advertisement data via BLE Manager, developer could config BLE data *pau8AdvData in Opl_Ble_Advertise_Data_Set Set BLE scan respnse data T_OplErr Opl_Ble_ScanRsp_Data_Set(uint8_t *pau8ScanRspData, uint8_t u8ScanRspDataLen) If BLE central scan, developer could set scan response data in BLE perpherial","title":"How to perform BLE process"},{"location":"application-guide/board_config.html","text":"Board Configuration Descript","title":"Board Configuration"},{"location":"application-guide/board_config.html#board-configuration","text":"Descript","title":"Board Configuration"},{"location":"application-guide/cloud.html","text":"Cloud Cloud Template Cloud Template is a template architecture that help the developer to integrate the device with the public/private cloud service and achieve the low power consumption and short latency purpose. The Cloud Template located at quick_dev/app_ref/cloud/cloud_template . Advantages of Cloud Template Advantages of Cloud Template are low power consumption and short latency. Cloud Template is divided into two tasks to be executed, different from a single task. If the cloud template is a single task, it will change to receive data after posting data to the cloud. These two events will run alternately, and the task will continue to be executed. This task would not enter the suspended state, and there will be times when it can\u2019t receive data during the post process. The two tasks can make RX task to receive data. When there is no data to receive, RX task will enter the state of suspension. It can achieve the effect of power saving. When posting data to the cloud, RX task can receive data more immediately. Rx task will not waste time waiting for the completion of the post to achieve the advantage of short latency. Cloud Template Architecture There are two components in Cloud Template, Cloud Kernel, and Cloud Control. Cloud Kernel : Cloud Kernel is responsible for receiving cloud events and data, then passing to event's handlers. Cloud Control : Cloud Control include several handlers. These handlers are responsible for executing cloud events through calling Protocol API. Note The developer can follow Opulinks provided template or implement event and event handlers depends on the features of the cloud to port. The following figure illustrates the Cloud template architecture, and the Cloud task process. Initialize Before porting the public/private cloud, please follow below steps to initiate. void APP_CldInit(void) { // user implement Cloud_Init(); } The Cloud TX task and Cloud RX task will be initiated in Cloud_Init. void Cloud_Init(void) { // create event group EG_Create(&g_tCloudEventGroup); // init tx task Cloud_TxTaskInit(); // init rx task Cloud_RxTaskInit(); } Several events can be handled in Cloud TX task: establishing a connection with the cloud disconnecting with the cloud binding to the cloud keeping alive with the cloud waiting for the ack of the cloud posting to cloud. How many events should be handled is depends on the features of the cloud to port. For example, the cloud establish event in the cloud template example. The Cloud TX task will receive cloud events, and execute the correspnding handlers found in event table g_tCloudTxEvtHandlerTbl . These handlers are responsible for executing cloud events through calling Protocol API. These handlers are located at Cloud Control.c . Note The developer can implement event and event handlers depends on the features of the cloud to port. static T_CloudTxEvtHandlerTbl g_tCloudTxEvtHandlerTbl[] = { {CLOUD_EVT_TYPE_INIT, Cloud_InitHandler}, {CLOUD_EVT_TYPE_ESTABLISH, Cloud_EstablishHandler}, {CLOUD_EVT_TYPE_DISCONNECT, Cloud_DisconnectHandler}, {CLOUD_EVT_TYPE_TIMEOUT, Cloud_TimeoutHandler}, {CLOUD_EVT_TYPE_BINDING, Cloud_BindingHandler}, {CLOUD_EVT_TYPE_KEEP_ALIVE, Cloud_KeepAliveHandler}, {CLOUD_EVT_TYPE_ACK, Cloud_AckHandler}, {CLOUD_EVT_TYPE_POST, Cloud_PostHandler}, #if (CLOUD_TX_DATA_BACKUP_ENABLED == 1) {CLOUD_EVT_TYPE_POST_BACKUP, Cloud_PostBackupHandler}, #endif }; Establish Connection With Cloud If the developer wanting to establish a connection with the cloud, the developer sends establish events from application to Cloud Kernel. Cloud TX task could get this event and data to pass to cloud control. The corresponding handler Cloud_EstablishHandler would get this event and call Protocol API (ex: TCP_Establish) to establish connection. Cloud_EstablishHandler (Cloud Control) handles the connection establishment with the cloud. The developer can call Protocol API to achieve cloud connection in Cloud_EstablishHandler . void Cloud_EstablishHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // user implement // 1. establish connection // 2. determine the connect status // if connect success - set connection status as online // Cloud_OnlineStatusSet(true); // if connect fail // error handle - call retry connection timer // osTimerStart(g_tCloudConnectRetryTimer, ConnRetryDuration); // 3. if connect success, start keep alive timer // Cloud_TimerStart(CLOUD_TMR_KEEP_ALIVE, CLOUD_KEEP_ALIVE_TIME); } Post Data To Cloud If the developer wanting to post data to the cloud, the developer sends post event and data from application to Cloud Kernel. Cloud TX task could get these event and data to pass cloud control. The developer can choose to construct your data and call Cloud_DataConstruct or you can also skip this step if you don't need it. The corresponding handler Cloud_PostHandler would pass data to Cloud_PostData . Cloud_PostData call Protocol API (ex:TCP_Send) to send data to cloud. Note The developer can implement the blue section in below sequence chart depends on the features of the cloud to port. ex: event, handler and data construct(optional). Cloud_PostHandler (Cloud Control) handles data posting to the cloud. The developer can call Protocol API to achieve to post data to the cloud in Cloud_PostHandler . void Cloud_PostHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement #if (CLOUD_TX_DATA_BACKUP_ENABLED == 1) // 1. create your own scenario to backup data by using RingBuf (Cloud_RingBuf___) // 2. construct data for post (if required) // Cloud_DataConstruct(pData, u32DataLen); // 3. post data // 4. send event CLOUD_EVT_TYPE_POST_BACKUP if RingBuf not empty #else // 1. construct income data for post (if required) // Cloud_DataConstruct(pData, u32DataLen); // 2. post data #endif /* CLOUD_TX_DATA_BACKUP_ENABLED */ } Receive Data from Cloud If the developer receiving data from the cloud, Cloud RX task in cloud kernel could call Cloud_ReceiveHandler in Cloud Control. Receive loop is composed of cloud RX task and Cloud_ReceiveHandler , Cloud_ReceiveHandler would call Protocol API(ex:TCP_Recv) to receive data from protocol. The developer can choose to parse data and call Cloud_DataParser in Cloud Control or skip this step. The user appliciation would receive data. Note The developer can implement the blue section in below sequence chart depends on the features of the cloud to port. ex: event, handler and data parse(optional). In cloud_kernel.c (Cloud Kernel), Cloud RX execute in Cloud_ReceiveHandler . Cloud_ReceiveHandler would handle receiving data from cloud. The developer can call Protocol API to achieve to receive data from the cloud in Cloud_ReceiveHandler . void Cloud_ReceiveHandler(void) { // user implement // 1. receive data from cloud // 2. determine the receive status // if received success - trigger data parser // Cloud_DataParser(pData, u32DataLen); //(marked to avoid compiler error) // if received fail // error handle // WARNING: IF DO NOTHING IN RECEIVE HANDLER, THE DELAY MUST EXIST // osDelay(1000); } Cloud Control Handler Template In addition to the previous handler, Opulinks also provided the following handler template, the developer can implement this handler depends on the features of the cloud to port. Cloud_DisconnectHandler (Cloud Control) handles the dsiconnection to the cloud. The developer can call Protocol API to achieve cloud disconnection in Cloud_DisconnectHandler . void Cloud_DisconnectHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // user implement // 1. close connection // 2. determine the disconnect result and change the connection status // if disconnect success - set connection status as offline // Cloud_OnlineStatusSet(false); // if disconnect fail // error handle // 3. if disconnect success, stop keep alive timer // Cloud_TimerStop(CLOUD_TMR_KEEP_ALIVE); } Cloud_BindingHandler (Cloud Control) handles the binding to the cloud. The developer can call Protocol API to achieve cloud binding in Cloud_BindingHandler . void Cloud_BindingHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement // 1. binding process } Cloud_KeepAliveHandler (Cloud Control) handles the keeping alive with the cloud. The developer can call Protocol API to achieve keeping alive with the cloud in Cloud_KeepAliveHandler . void Cloud_KeepAliveHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement // 1. post keep alive data // 2. restart keep alive timer // Cloud_TimerStart(CLOUD_TMR_KEEP_ALIVE, CLOUD_KEEP_ALIVE_TIME); } Cloud_AckHandler (Cloud Control) handles the ack posting to the cloud. The developer can call Protocol API to achieve to post ack to the cloud in Cloud_AckHandler . void Cloud_AckHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement // 1. post ack data } How To... How to port public/private cloud that utilizes Cloud Template The developer can copy the folder quick_dev\\app_ref\\cloud\\cloud_template to quick_dev\\app_ref\\cloud that copied folder could rename my_cloud to execute cloud process. There are two important files cloud_kernel.c (Cloud Kernel) & cloud_ctrl.c (Cloud Control). Cloud Kernel is responsible for receiving cloud events and data, then passing to these event's handlers. These handlers are located at Cloud Control. In cloud_kernel.c (Cloud Kernel), there are two components that are Cloud_TxTaskHandler (Cloud TX) and Cloud_RxTaskHandler (Cloud RX). Cloud TX process Cloud_TxTaskHandler is based on the cloud kernel event table g_tCloudTxEvtHandlerTbl . Some important events that are CLOUD_EVT_TYPE_ESTABLISH (establish connection with the cloud), CLOUD_EVT_TYPE_DISCONNECT (disconnect to the cloud), CLOUD_EVT_TYPE_KEEP_ALIVE (keep alive with the cloud), CLOUD_EVT_TYPE_ACK (response ack to the cloud) and CLOUD_EVT_TYPE_POST (post data to the cloud). There are the corresponding handlers (Cloud Control) to handle these events and pass to protocol to execute cloud kernel event. // cloud kernel event table static T_CloudTxEvtHandlerTbl g_tCloudTxEvtHandlerTbl[] = { {CLOUD_EVT_TYPE_INIT, Cloud_InitHandler}, {CLOUD_EVT_TYPE_ESTABLISH, Cloud_EstablishHandler}, {CLOUD_EVT_TYPE_DISCONNECT, Cloud_DisconnectHandler}, {CLOUD_EVT_TYPE_TIMEOUT, Cloud_TimeoutHandler}, {CLOUD_EVT_TYPE_BINDING, Cloud_BindingHandler}, {CLOUD_EVT_TYPE_KEEP_ALIVE, Cloud_KeepAliveHandler}, {CLOUD_EVT_TYPE_ACK, Cloud_AckHandler}, {CLOUD_EVT_TYPE_POST, Cloud_PostHandler}, #if (CLOUD_TX_DATA_BACKUP_ENABLED == 1) {CLOUD_EVT_TYPE_POST_BACKUP, Cloud_PostBackupHandler}, #endif }; For example, if wnating to post datas to the cloud (TCP Cloud), the developer send post events and data from application to Cloud Kernel (Cloud TX task). Cloud TX task could gets these event and data to pass the corresponding handler Cloud_PostHandler . Cloud_PostHandler would construct data and pass data to Cloud_PostData . void Cloud_PostData(uint8_t *pu8Data, uint32_t u32DataLen) { ... i32Ret = TCP_Send(g_ptrCloudTcpHdlId, (const char *)pu8Data, u32DataLen, TCP_TX_POST_TIMEOUT); ... } Cloud_PostData call TCP_Send (Cloud Control) to send data to send (TCP Protocol). int TCP_Send(uintptr_t fd, const char *buf, uint32_t len, uint32_t timeout_ms) { ... ret = send(fd, buf, len, 0); ... } Cloud RX process In cloud_kernel.c (Cloud Kernel), Cloud RX execute in Cloud_ReceiveHandler . Cloud_ReceiveHandler would call TCP_Recv (Cloud Control) to receive data from protocol. For example, if receiving data from the cloud (TCP CLOUD), the developer could use TCP_Recv (Cloud Control) call select (TCP protocol) to receive data and pass to Cloud_ReceiveHandler (Cloud Kernel). nt TCP_Recv(uintptr_t fd, char *buf, uint32_t len, uint32_t timeout_ms) { ... ret = select(fd + 1, &sets, NULL, NULL, &timeout); ... }","title":"Cloud"},{"location":"application-guide/cloud.html#cloud","text":"","title":"Cloud"},{"location":"application-guide/cloud.html#cloud-template","text":"Cloud Template is a template architecture that help the developer to integrate the device with the public/private cloud service and achieve the low power consumption and short latency purpose. The Cloud Template located at quick_dev/app_ref/cloud/cloud_template .","title":"Cloud Template"},{"location":"application-guide/cloud.html#advantages-of-cloud-template","text":"Advantages of Cloud Template are low power consumption and short latency. Cloud Template is divided into two tasks to be executed, different from a single task. If the cloud template is a single task, it will change to receive data after posting data to the cloud. These two events will run alternately, and the task will continue to be executed. This task would not enter the suspended state, and there will be times when it can\u2019t receive data during the post process. The two tasks can make RX task to receive data. When there is no data to receive, RX task will enter the state of suspension. It can achieve the effect of power saving. When posting data to the cloud, RX task can receive data more immediately. Rx task will not waste time waiting for the completion of the post to achieve the advantage of short latency.","title":"Advantages of Cloud Template"},{"location":"application-guide/cloud.html#cloud-template-architecture","text":"There are two components in Cloud Template, Cloud Kernel, and Cloud Control. Cloud Kernel : Cloud Kernel is responsible for receiving cloud events and data, then passing to event's handlers. Cloud Control : Cloud Control include several handlers. These handlers are responsible for executing cloud events through calling Protocol API. Note The developer can follow Opulinks provided template or implement event and event handlers depends on the features of the cloud to port. The following figure illustrates the Cloud template architecture, and the Cloud task process.","title":"Cloud Template Architecture"},{"location":"application-guide/cloud.html#initialize","text":"Before porting the public/private cloud, please follow below steps to initiate. void APP_CldInit(void) { // user implement Cloud_Init(); } The Cloud TX task and Cloud RX task will be initiated in Cloud_Init. void Cloud_Init(void) { // create event group EG_Create(&g_tCloudEventGroup); // init tx task Cloud_TxTaskInit(); // init rx task Cloud_RxTaskInit(); } Several events can be handled in Cloud TX task: establishing a connection with the cloud disconnecting with the cloud binding to the cloud keeping alive with the cloud waiting for the ack of the cloud posting to cloud. How many events should be handled is depends on the features of the cloud to port. For example, the cloud establish event in the cloud template example. The Cloud TX task will receive cloud events, and execute the correspnding handlers found in event table g_tCloudTxEvtHandlerTbl . These handlers are responsible for executing cloud events through calling Protocol API. These handlers are located at Cloud Control.c . Note The developer can implement event and event handlers depends on the features of the cloud to port. static T_CloudTxEvtHandlerTbl g_tCloudTxEvtHandlerTbl[] = { {CLOUD_EVT_TYPE_INIT, Cloud_InitHandler}, {CLOUD_EVT_TYPE_ESTABLISH, Cloud_EstablishHandler}, {CLOUD_EVT_TYPE_DISCONNECT, Cloud_DisconnectHandler}, {CLOUD_EVT_TYPE_TIMEOUT, Cloud_TimeoutHandler}, {CLOUD_EVT_TYPE_BINDING, Cloud_BindingHandler}, {CLOUD_EVT_TYPE_KEEP_ALIVE, Cloud_KeepAliveHandler}, {CLOUD_EVT_TYPE_ACK, Cloud_AckHandler}, {CLOUD_EVT_TYPE_POST, Cloud_PostHandler}, #if (CLOUD_TX_DATA_BACKUP_ENABLED == 1) {CLOUD_EVT_TYPE_POST_BACKUP, Cloud_PostBackupHandler}, #endif };","title":"Initialize"},{"location":"application-guide/cloud.html#establish-connection-with-cloud","text":"If the developer wanting to establish a connection with the cloud, the developer sends establish events from application to Cloud Kernel. Cloud TX task could get this event and data to pass to cloud control. The corresponding handler Cloud_EstablishHandler would get this event and call Protocol API (ex: TCP_Establish) to establish connection. Cloud_EstablishHandler (Cloud Control) handles the connection establishment with the cloud. The developer can call Protocol API to achieve cloud connection in Cloud_EstablishHandler . void Cloud_EstablishHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // user implement // 1. establish connection // 2. determine the connect status // if connect success - set connection status as online // Cloud_OnlineStatusSet(true); // if connect fail // error handle - call retry connection timer // osTimerStart(g_tCloudConnectRetryTimer, ConnRetryDuration); // 3. if connect success, start keep alive timer // Cloud_TimerStart(CLOUD_TMR_KEEP_ALIVE, CLOUD_KEEP_ALIVE_TIME); }","title":"Establish Connection With Cloud"},{"location":"application-guide/cloud.html#post-data-to-cloud","text":"If the developer wanting to post data to the cloud, the developer sends post event and data from application to Cloud Kernel. Cloud TX task could get these event and data to pass cloud control. The developer can choose to construct your data and call Cloud_DataConstruct or you can also skip this step if you don't need it. The corresponding handler Cloud_PostHandler would pass data to Cloud_PostData . Cloud_PostData call Protocol API (ex:TCP_Send) to send data to cloud. Note The developer can implement the blue section in below sequence chart depends on the features of the cloud to port. ex: event, handler and data construct(optional). Cloud_PostHandler (Cloud Control) handles data posting to the cloud. The developer can call Protocol API to achieve to post data to the cloud in Cloud_PostHandler . void Cloud_PostHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement #if (CLOUD_TX_DATA_BACKUP_ENABLED == 1) // 1. create your own scenario to backup data by using RingBuf (Cloud_RingBuf___) // 2. construct data for post (if required) // Cloud_DataConstruct(pData, u32DataLen); // 3. post data // 4. send event CLOUD_EVT_TYPE_POST_BACKUP if RingBuf not empty #else // 1. construct income data for post (if required) // Cloud_DataConstruct(pData, u32DataLen); // 2. post data #endif /* CLOUD_TX_DATA_BACKUP_ENABLED */ }","title":"Post Data To Cloud"},{"location":"application-guide/cloud.html#receive-data-from-cloud","text":"If the developer receiving data from the cloud, Cloud RX task in cloud kernel could call Cloud_ReceiveHandler in Cloud Control. Receive loop is composed of cloud RX task and Cloud_ReceiveHandler , Cloud_ReceiveHandler would call Protocol API(ex:TCP_Recv) to receive data from protocol. The developer can choose to parse data and call Cloud_DataParser in Cloud Control or skip this step. The user appliciation would receive data. Note The developer can implement the blue section in below sequence chart depends on the features of the cloud to port. ex: event, handler and data parse(optional). In cloud_kernel.c (Cloud Kernel), Cloud RX execute in Cloud_ReceiveHandler . Cloud_ReceiveHandler would handle receiving data from cloud. The developer can call Protocol API to achieve to receive data from the cloud in Cloud_ReceiveHandler . void Cloud_ReceiveHandler(void) { // user implement // 1. receive data from cloud // 2. determine the receive status // if received success - trigger data parser // Cloud_DataParser(pData, u32DataLen); //(marked to avoid compiler error) // if received fail // error handle // WARNING: IF DO NOTHING IN RECEIVE HANDLER, THE DELAY MUST EXIST // osDelay(1000); }","title":"Receive Data from Cloud"},{"location":"application-guide/cloud.html#cloud-control-handler-template","text":"In addition to the previous handler, Opulinks also provided the following handler template, the developer can implement this handler depends on the features of the cloud to port. Cloud_DisconnectHandler (Cloud Control) handles the dsiconnection to the cloud. The developer can call Protocol API to achieve cloud disconnection in Cloud_DisconnectHandler . void Cloud_DisconnectHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // user implement // 1. close connection // 2. determine the disconnect result and change the connection status // if disconnect success - set connection status as offline // Cloud_OnlineStatusSet(false); // if disconnect fail // error handle // 3. if disconnect success, stop keep alive timer // Cloud_TimerStop(CLOUD_TMR_KEEP_ALIVE); } Cloud_BindingHandler (Cloud Control) handles the binding to the cloud. The developer can call Protocol API to achieve cloud binding in Cloud_BindingHandler . void Cloud_BindingHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement // 1. binding process } Cloud_KeepAliveHandler (Cloud Control) handles the keeping alive with the cloud. The developer can call Protocol API to achieve keeping alive with the cloud in Cloud_KeepAliveHandler . void Cloud_KeepAliveHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement // 1. post keep alive data // 2. restart keep alive timer // Cloud_TimerStart(CLOUD_TMR_KEEP_ALIVE, CLOUD_KEEP_ALIVE_TIME); } Cloud_AckHandler (Cloud Control) handles the ack posting to the cloud. The developer can call Protocol API to achieve to post ack to the cloud in Cloud_AckHandler . void Cloud_AckHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement // 1. post ack data }","title":"Cloud Control Handler Template"},{"location":"application-guide/cloud.html#how-to","text":"","title":"How To..."},{"location":"application-guide/cloud.html#how-to-port-publicprivate-cloud-that-utilizes-cloud-template","text":"The developer can copy the folder quick_dev\\app_ref\\cloud\\cloud_template to quick_dev\\app_ref\\cloud that copied folder could rename my_cloud to execute cloud process. There are two important files cloud_kernel.c (Cloud Kernel) & cloud_ctrl.c (Cloud Control). Cloud Kernel is responsible for receiving cloud events and data, then passing to these event's handlers. These handlers are located at Cloud Control. In cloud_kernel.c (Cloud Kernel), there are two components that are Cloud_TxTaskHandler (Cloud TX) and Cloud_RxTaskHandler (Cloud RX). Cloud TX process Cloud_TxTaskHandler is based on the cloud kernel event table g_tCloudTxEvtHandlerTbl . Some important events that are CLOUD_EVT_TYPE_ESTABLISH (establish connection with the cloud), CLOUD_EVT_TYPE_DISCONNECT (disconnect to the cloud), CLOUD_EVT_TYPE_KEEP_ALIVE (keep alive with the cloud), CLOUD_EVT_TYPE_ACK (response ack to the cloud) and CLOUD_EVT_TYPE_POST (post data to the cloud). There are the corresponding handlers (Cloud Control) to handle these events and pass to protocol to execute cloud kernel event. // cloud kernel event table static T_CloudTxEvtHandlerTbl g_tCloudTxEvtHandlerTbl[] = { {CLOUD_EVT_TYPE_INIT, Cloud_InitHandler}, {CLOUD_EVT_TYPE_ESTABLISH, Cloud_EstablishHandler}, {CLOUD_EVT_TYPE_DISCONNECT, Cloud_DisconnectHandler}, {CLOUD_EVT_TYPE_TIMEOUT, Cloud_TimeoutHandler}, {CLOUD_EVT_TYPE_BINDING, Cloud_BindingHandler}, {CLOUD_EVT_TYPE_KEEP_ALIVE, Cloud_KeepAliveHandler}, {CLOUD_EVT_TYPE_ACK, Cloud_AckHandler}, {CLOUD_EVT_TYPE_POST, Cloud_PostHandler}, #if (CLOUD_TX_DATA_BACKUP_ENABLED == 1) {CLOUD_EVT_TYPE_POST_BACKUP, Cloud_PostBackupHandler}, #endif }; For example, if wnating to post datas to the cloud (TCP Cloud), the developer send post events and data from application to Cloud Kernel (Cloud TX task). Cloud TX task could gets these event and data to pass the corresponding handler Cloud_PostHandler . Cloud_PostHandler would construct data and pass data to Cloud_PostData . void Cloud_PostData(uint8_t *pu8Data, uint32_t u32DataLen) { ... i32Ret = TCP_Send(g_ptrCloudTcpHdlId, (const char *)pu8Data, u32DataLen, TCP_TX_POST_TIMEOUT); ... } Cloud_PostData call TCP_Send (Cloud Control) to send data to send (TCP Protocol). int TCP_Send(uintptr_t fd, const char *buf, uint32_t len, uint32_t timeout_ms) { ... ret = send(fd, buf, len, 0); ... } Cloud RX process In cloud_kernel.c (Cloud Kernel), Cloud RX execute in Cloud_ReceiveHandler . Cloud_ReceiveHandler would call TCP_Recv (Cloud Control) to receive data from protocol. For example, if receiving data from the cloud (TCP CLOUD), the developer could use TCP_Recv (Cloud Control) call select (TCP protocol) to receive data and pass to Cloud_ReceiveHandler (Cloud Kernel). nt TCP_Recv(uintptr_t fd, char *buf, uint32_t len, uint32_t timeout_ms) { ... ret = select(fd + 1, &sets, NULL, NULL, &timeout); ... }","title":"How to port public/private cloud that utilizes Cloud Template"},{"location":"application-guide/log_config.html","text":"Log Configuration The Log Configuration quick_dev\\common\\log\\log.h is the configuration that package one layer on bottom layer tracer_log in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . The log configuration can help developer to trace and debug in application, the log can divide into four types that are debug, information, warnnimg and error. The developer can switch the log level that they want to see according to their needs. To enter tracer level <task_index> <task_level:hex> could turn on tracer level in debug console. If wanting to trace log with Log Configration, the developer could use tracer_def_level_set() to set trcae log. The developer can refer to the following examples static void Main_AppInit_patch(void) { sys_cfg_clk_set(SYS_CFG_CLK_RATE); // set default tracer level in user app type to INFO, WARN, ERRO (DEBG not open) tracer_def_level_set(TRACER_TASK_TYPE_APP, 0x06); APP_MainInit(); } The argument TRACER_TASK_TYPE_APP is a trace type that include TRACER_TASK_TYPE_INTERNAL (bottom layer) and TRACER_TASK_TYPE_APP (application) defined in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . typedef enum { TRACER_TASK_TYPE_INTERNAL = 0, TRACER_TASK_TYPE_APP, TRACER_TASK_TYPE_MAX } T_TracerTaskType; The other argument 0x06 is trace level that developer want to trace. There are the following trace level in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . #define LOG_HIGH_LEVEL 0x04 #define LOG_MED_LEVEL 0x02 #define LOG_LOW_LEVEL 0x01 #define LOG_NONE_LEVEL 0x00 #define LOG_ALL_LEVEL (LOG_HIGH_LEVEL | LOG_MED_LEVEL | LOG_LOW_LEVEL) The argument 0x06 means trace log level turn on LOG_HIGH_LEVEL and LOG_MED_LEVEL but LOG_LOW_LEVEL is turn off. Log Configuration has the following log levels : Debug ( LOG_LOW_LEVEL ) #define OPL_LOG_DEBG(module, ...) \\ { \\ tracer_log(LOG_LOW_LEVEL, \"\\x1B[0m[D][%s]\", #module); \\ tracer_log(LOG_LOW_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_LOW_LEVEL, \"\\r\\n\"); \\ } Info ( LOG_MED_LEVEL ) #define OPL_LOG_INFO(module, ...) \\ { \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[0m[I][%s]\", #module); \\ tracer_log(LOG_MED_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_MED_LEVEL, \"\\r\\n\"); \\ } Warn ( LOG_MED_LEVEL ) #define OPL_LOG_WARN(module, ...) \\ { \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[33m[W][%s]\", #module); \\ tracer_log(LOG_MED_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[0m\\r\\n\"); \\ } Error ( LOG_HIGH_LEVEL ) #define OPL_LOG_ERRO(module, ...) \\ { \\ tracer_log(LOG_HIGH_LEVEL, \"\\x1B[31m[E][%s]\", #module); \\ tracer_log(LOG_HIGH_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_HIGH_LEVEL, \"\\x1B[0m\\r\\n\"); \\ } The developer could set what module in the argument module . Log configuration can also be set according to the log of which module (e.g. BLE Manager log)the developer wants to see in qd_module.h . Module log enable set (1) (e.g. BM_LOG_ENABLED) #ifndef BM_LOG_ENABLED #define BM_LOG_ENABLED (1) #endif","title":"Log Configuration"},{"location":"application-guide/log_config.html#log-configuration","text":"The Log Configuration quick_dev\\common\\log\\log.h is the configuration that package one layer on bottom layer tracer_log in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . The log configuration can help developer to trace and debug in application, the log can divide into four types that are debug, information, warnnimg and error. The developer can switch the log level that they want to see according to their needs. To enter tracer level <task_index> <task_level:hex> could turn on tracer level in debug console. If wanting to trace log with Log Configration, the developer could use tracer_def_level_set() to set trcae log. The developer can refer to the following examples static void Main_AppInit_patch(void) { sys_cfg_clk_set(SYS_CFG_CLK_RATE); // set default tracer level in user app type to INFO, WARN, ERRO (DEBG not open) tracer_def_level_set(TRACER_TASK_TYPE_APP, 0x06); APP_MainInit(); } The argument TRACER_TASK_TYPE_APP is a trace type that include TRACER_TASK_TYPE_INTERNAL (bottom layer) and TRACER_TASK_TYPE_APP (application) defined in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . typedef enum { TRACER_TASK_TYPE_INTERNAL = 0, TRACER_TASK_TYPE_APP, TRACER_TASK_TYPE_MAX } T_TracerTaskType; The other argument 0x06 is trace level that developer want to trace. There are the following trace level in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . #define LOG_HIGH_LEVEL 0x04 #define LOG_MED_LEVEL 0x02 #define LOG_LOW_LEVEL 0x01 #define LOG_NONE_LEVEL 0x00 #define LOG_ALL_LEVEL (LOG_HIGH_LEVEL | LOG_MED_LEVEL | LOG_LOW_LEVEL) The argument 0x06 means trace log level turn on LOG_HIGH_LEVEL and LOG_MED_LEVEL but LOG_LOW_LEVEL is turn off. Log Configuration has the following log levels : Debug ( LOG_LOW_LEVEL ) #define OPL_LOG_DEBG(module, ...) \\ { \\ tracer_log(LOG_LOW_LEVEL, \"\\x1B[0m[D][%s]\", #module); \\ tracer_log(LOG_LOW_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_LOW_LEVEL, \"\\r\\n\"); \\ } Info ( LOG_MED_LEVEL ) #define OPL_LOG_INFO(module, ...) \\ { \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[0m[I][%s]\", #module); \\ tracer_log(LOG_MED_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_MED_LEVEL, \"\\r\\n\"); \\ } Warn ( LOG_MED_LEVEL ) #define OPL_LOG_WARN(module, ...) \\ { \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[33m[W][%s]\", #module); \\ tracer_log(LOG_MED_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[0m\\r\\n\"); \\ } Error ( LOG_HIGH_LEVEL ) #define OPL_LOG_ERRO(module, ...) \\ { \\ tracer_log(LOG_HIGH_LEVEL, \"\\x1B[31m[E][%s]\", #module); \\ tracer_log(LOG_HIGH_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_HIGH_LEVEL, \"\\x1B[0m\\r\\n\"); \\ } The developer could set what module in the argument module . Log configuration can also be set according to the log of which module (e.g. BLE Manager log)the developer wants to see in qd_module.h . Module log enable set (1) (e.g. BM_LOG_ENABLED) #ifndef BM_LOG_ENABLED #define BM_LOG_ENABLED (1) #endif","title":"Log Configuration"},{"location":"application-guide/mp.html","text":"MP","title":"MP"},{"location":"application-guide/mp.html#mp","text":"","title":"MP"},{"location":"application-guide/ota.html","text":"OTA Over-The-Air (OTA) is a procedure to update the firmware without the use of physical wires. OTA is responsible for the flash procedure. The OTA data can be received from phone app via BLE or cloud via Wi-Fi connection. When a product is ready and released in the field, OTA can be used to upload new firmware that brings new features. OTA via BLE \"OTA via BLE\" can complete firmware update via Bluetooth from the mobile phone APP (e.g. \"Opulinks\"). First, send an \"OTA request\" message to the device from the mobile phone. After receiving, BLE Application will parse the \"OTA request\" message and request OTA Manager to execute OTA process. The developer can call BLE Application API OPL_DataRecvHandler to pass the \"OTA request\" message to BLE Application when this message enters User Application from BLE Manager. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); } There are four stage in OTA procedure. #if (OTA_ENABLED == 1) {OPL_DATA_REQ_OTA_VERSION, OPL_DataProtocol_OtaVersion}, {OPL_DATA_REQ_OTA_UPGRADE, OPL_DataProtocol_OtaUpgrade}, {OPL_DATA_REQ_OTA_RAW, OPL_DataProtocol_OtaRaw}, {OPL_DATA_REQ_OTA_END, OPL_DataProtocol_OtaEnd}, #endif To start OTA, the BLE Application will first receive an event OPL_DATA_REQ_OTA_VERSION and call OTA Manager API OTA_CurrentVersionGet to get current OTA firmware version. static void OPL_DataProtocol_OtaVersion(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_VERSION\"); uint16_t pid; uint16_t cid; uint16_t fid; T_OplErr tEvtRst = OTA_CurrentVersionGet(&pid, &cid, &fid); if (OPL_OK != tEvtRst) OPL_OtaSendVersionRsp(OPL_DATA_OTA_ERR_HW_FAILURE, 0, 0, 0); else OPL_OtaSendVersionRsp(OPL_DATA_OTA_SUCCESS, pid, cid, fid); } If checking OTA firmware version OK, the device will receive OPL_DATA_REQ_OTA_UPGRADE and call OTA Manager API OTA_UpgradeBegin to start to upgrade firmware. static void OPL_DataProtocol_OtaUpgrade(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_UPGRADE\"); T_OplOtaData *ota = gTheOta; T_OplErr tEvtRst = OPL_OK; tEvtRst = OTA_UpgradeBegin(&g_u16OtaSeqId, ota_hdr, OPL_OtaTimeoutIndCb); if(OPL_OK == tEvtRst) { OPL_OtaSendUpgradeRsp(OPL_DATA_OTA_SUCCESS); gTheOta = ota; } else { OPL_SendEndRsp(OPL_DATA_OTA_ERR_HW_FAILURE, TRUE); } } If starting OTA upgrading OK, the device will receive OPL_DATA_REQ_OTA_RAW and call OTA Manager API OTA_WriteData to start raw data of new firmware from mobile phone. static void OPL_DataProtocol_OtaRaw(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_RAW\"); T_OplOtaData *ota = gTheOta; T_OplErr tEvtRst = OPL_OK; tEvtRst = OTA_WriteData(g_u16OtaSeqId, ota->buf, 256); return; } If rawing data successfully, the device will receive OPL_DATA_REQ_OTA_END and call OTA Manager API OTA_UpgradeFinish to finish OTA process. static void OPL_DataProtocol_OtaEnd(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_END\"); T_OplOtaData *ota = gTheOta; uint8_t status = data[0]; if(OPL_OK == OTA_UpgradeFinish(g_u16OtaSeqId)) { OPL_SendEndRsp(OPL_DATA_OTA_SUCCESS, TRUE); } else { OPL_SendEndRsp(OPL_DATA_OTA_ERR_CHECKSUM, TRUE); } return; } OTA via WI-FI \"OTA via WI-FI\" update mechanism helps users to easily and securely update the new firmware on their device through Wi-Fi. To enable WI-FI OTA, the developer should enable CLOUD_OTA_ENABLED in cloud_config.h . // WI-FI ota enable (OTA_ENABLE and OTA_Init() must required) #ifndef CLOUD_OTA_ENABLED #define CLOUD_OTA_ENABLED (1) #endif cloud_ota_http.c (Cloud OTA) is responsible for retrieving OTA data from cloud. In Cloud_OtaTaskHandler , the OTA event CLOUD_OTA_EVT_TYPE_DOWNLOAD will be received and then it applies Cloud_OtaHttpDownload to complete OTA process. void Cloud_OtaTaskHandler(void *args) { osEvent tEvent; T_CloudDataMsg *ptCloudOtaMsg; for(;;) { // wait event tEvent = osMessageGet(g_tCloudOtaQueueId, osWaitForever); if(tEvent.status == osEventMessage) { ptCloudOtaMsg = (T_CloudDataMsg *)tEvent.value.p; switch(ptCloudOtaMsg->u32EventId) { case CLOUD_OTA_EVT_TYPE_DOWNLOAD: { int32_t i32Ret = Cloud_OtaHttpDownload((char *)ptCloudOtaMsg->u8aData, (int)ptCloudOtaMsg->u32DataLen); break; } } } } } Cloud_OtaHttpDownload is a single task to execute \"OTA via WI-FI\" process. \"OTA via WI-FI\" process include connecting to http server, getting current OTA version, retrieving raw data of new firmware from cloud, and finishing OTA process via OTA Manager. int32_t Cloud_OtaHttpDownload(char *url, int len) { char get_url[CLOUD_OTA_HTTP_URL_LEN]; char *buf; int8_t i8Ret = HTTPCLIENT_ERROR_CONN; uint32_t u16UrlLen = strlen(url); uint16_t u16Pid, u16Cid, u16Fid; uint8_t u8RetryCount = 0; // connect to http server do { i8Ret = httpclient_connect(&g_tCloudOtaHttpClient, get_url); if(!i8Ret) { OPL_LOG_INFO(CLOUD, \"Connect to http server\"); break; } else { osDelay(1000); u8RetryCount ++; OPL_LOG_WARN(CLOUD, \"Connect to http server fail, retry count (%d)\", u8RetryCount); } } while(u8RetryCount < CLOUD_OTA_HTTP_CONNECTION_RETRY_COUNT); // get current ota version OTA_CurrentVersionGet(&u16Pid, &u16Cid, &u16Fid); OPL_LOG_DEBG(CLOUD, \"pid=%d, cid=%d, fid=%d\", u16Pid, u16Cid, u16Fid); //raw data of new firmware from the cloud i8Ret = _Cloud_OtaHttpRetrieveGet(get_url, buf, CLOUD_OTA_HTTP_DATA_LEN); if(0 > i8Ret) { if(OPL_OK != OTA_UpgradeGiveUp(g_u16OtaSeqId)) { OPL_LOG_ERRO(CLOUD, \"OTA give up fail\"); } } else { //complete OTA if(OPL_OK != OTA_UpgradeFinish(g_u16OtaSeqId)) { OPL_LOG_ERRO(CLOUD, \"OTA finish fail\"); } } OPL_LOG_INFO(CLOUD, \"download result = %d\", i8Ret); // close http connection httpclient_close(&g_tCloudOtaHttpClient); free(buf); buf = NULL; return i8Ret; } How To... How to execute OTA via WI-FI in a single task Cloud_OtaHttpDownload is a single task to execute \"OTA via WI-FI\" process Apply httpclient_connect to connect http server Apply OTA_CurrentVersionGet Get current OTA firmware version via OTA Manager Apply _Cloud_OtaHttpRetrieveGet to retrieve raw data of new firmware from the cloud If retrieving sucessfully, apply OTA_UpgradeFinish to complete OTA via OTA Manager Apply httpclient_close to close http connection","title":"OTA"},{"location":"application-guide/ota.html#ota","text":"Over-The-Air (OTA) is a procedure to update the firmware without the use of physical wires. OTA is responsible for the flash procedure. The OTA data can be received from phone app via BLE or cloud via Wi-Fi connection. When a product is ready and released in the field, OTA can be used to upload new firmware that brings new features.","title":"OTA"},{"location":"application-guide/ota.html#ota-via-ble","text":"\"OTA via BLE\" can complete firmware update via Bluetooth from the mobile phone APP (e.g. \"Opulinks\"). First, send an \"OTA request\" message to the device from the mobile phone. After receiving, BLE Application will parse the \"OTA request\" message and request OTA Manager to execute OTA process. The developer can call BLE Application API OPL_DataRecvHandler to pass the \"OTA request\" message to BLE Application when this message enters User Application from BLE Manager. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); } There are four stage in OTA procedure. #if (OTA_ENABLED == 1) {OPL_DATA_REQ_OTA_VERSION, OPL_DataProtocol_OtaVersion}, {OPL_DATA_REQ_OTA_UPGRADE, OPL_DataProtocol_OtaUpgrade}, {OPL_DATA_REQ_OTA_RAW, OPL_DataProtocol_OtaRaw}, {OPL_DATA_REQ_OTA_END, OPL_DataProtocol_OtaEnd}, #endif To start OTA, the BLE Application will first receive an event OPL_DATA_REQ_OTA_VERSION and call OTA Manager API OTA_CurrentVersionGet to get current OTA firmware version. static void OPL_DataProtocol_OtaVersion(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_VERSION\"); uint16_t pid; uint16_t cid; uint16_t fid; T_OplErr tEvtRst = OTA_CurrentVersionGet(&pid, &cid, &fid); if (OPL_OK != tEvtRst) OPL_OtaSendVersionRsp(OPL_DATA_OTA_ERR_HW_FAILURE, 0, 0, 0); else OPL_OtaSendVersionRsp(OPL_DATA_OTA_SUCCESS, pid, cid, fid); } If checking OTA firmware version OK, the device will receive OPL_DATA_REQ_OTA_UPGRADE and call OTA Manager API OTA_UpgradeBegin to start to upgrade firmware. static void OPL_DataProtocol_OtaUpgrade(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_UPGRADE\"); T_OplOtaData *ota = gTheOta; T_OplErr tEvtRst = OPL_OK; tEvtRst = OTA_UpgradeBegin(&g_u16OtaSeqId, ota_hdr, OPL_OtaTimeoutIndCb); if(OPL_OK == tEvtRst) { OPL_OtaSendUpgradeRsp(OPL_DATA_OTA_SUCCESS); gTheOta = ota; } else { OPL_SendEndRsp(OPL_DATA_OTA_ERR_HW_FAILURE, TRUE); } } If starting OTA upgrading OK, the device will receive OPL_DATA_REQ_OTA_RAW and call OTA Manager API OTA_WriteData to start raw data of new firmware from mobile phone. static void OPL_DataProtocol_OtaRaw(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_RAW\"); T_OplOtaData *ota = gTheOta; T_OplErr tEvtRst = OPL_OK; tEvtRst = OTA_WriteData(g_u16OtaSeqId, ota->buf, 256); return; } If rawing data successfully, the device will receive OPL_DATA_REQ_OTA_END and call OTA Manager API OTA_UpgradeFinish to finish OTA process. static void OPL_DataProtocol_OtaEnd(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_END\"); T_OplOtaData *ota = gTheOta; uint8_t status = data[0]; if(OPL_OK == OTA_UpgradeFinish(g_u16OtaSeqId)) { OPL_SendEndRsp(OPL_DATA_OTA_SUCCESS, TRUE); } else { OPL_SendEndRsp(OPL_DATA_OTA_ERR_CHECKSUM, TRUE); } return; }","title":"OTA via BLE"},{"location":"application-guide/ota.html#ota-via-wi-fi","text":"\"OTA via WI-FI\" update mechanism helps users to easily and securely update the new firmware on their device through Wi-Fi. To enable WI-FI OTA, the developer should enable CLOUD_OTA_ENABLED in cloud_config.h . // WI-FI ota enable (OTA_ENABLE and OTA_Init() must required) #ifndef CLOUD_OTA_ENABLED #define CLOUD_OTA_ENABLED (1) #endif cloud_ota_http.c (Cloud OTA) is responsible for retrieving OTA data from cloud. In Cloud_OtaTaskHandler , the OTA event CLOUD_OTA_EVT_TYPE_DOWNLOAD will be received and then it applies Cloud_OtaHttpDownload to complete OTA process. void Cloud_OtaTaskHandler(void *args) { osEvent tEvent; T_CloudDataMsg *ptCloudOtaMsg; for(;;) { // wait event tEvent = osMessageGet(g_tCloudOtaQueueId, osWaitForever); if(tEvent.status == osEventMessage) { ptCloudOtaMsg = (T_CloudDataMsg *)tEvent.value.p; switch(ptCloudOtaMsg->u32EventId) { case CLOUD_OTA_EVT_TYPE_DOWNLOAD: { int32_t i32Ret = Cloud_OtaHttpDownload((char *)ptCloudOtaMsg->u8aData, (int)ptCloudOtaMsg->u32DataLen); break; } } } } } Cloud_OtaHttpDownload is a single task to execute \"OTA via WI-FI\" process. \"OTA via WI-FI\" process include connecting to http server, getting current OTA version, retrieving raw data of new firmware from cloud, and finishing OTA process via OTA Manager. int32_t Cloud_OtaHttpDownload(char *url, int len) { char get_url[CLOUD_OTA_HTTP_URL_LEN]; char *buf; int8_t i8Ret = HTTPCLIENT_ERROR_CONN; uint32_t u16UrlLen = strlen(url); uint16_t u16Pid, u16Cid, u16Fid; uint8_t u8RetryCount = 0; // connect to http server do { i8Ret = httpclient_connect(&g_tCloudOtaHttpClient, get_url); if(!i8Ret) { OPL_LOG_INFO(CLOUD, \"Connect to http server\"); break; } else { osDelay(1000); u8RetryCount ++; OPL_LOG_WARN(CLOUD, \"Connect to http server fail, retry count (%d)\", u8RetryCount); } } while(u8RetryCount < CLOUD_OTA_HTTP_CONNECTION_RETRY_COUNT); // get current ota version OTA_CurrentVersionGet(&u16Pid, &u16Cid, &u16Fid); OPL_LOG_DEBG(CLOUD, \"pid=%d, cid=%d, fid=%d\", u16Pid, u16Cid, u16Fid); //raw data of new firmware from the cloud i8Ret = _Cloud_OtaHttpRetrieveGet(get_url, buf, CLOUD_OTA_HTTP_DATA_LEN); if(0 > i8Ret) { if(OPL_OK != OTA_UpgradeGiveUp(g_u16OtaSeqId)) { OPL_LOG_ERRO(CLOUD, \"OTA give up fail\"); } } else { //complete OTA if(OPL_OK != OTA_UpgradeFinish(g_u16OtaSeqId)) { OPL_LOG_ERRO(CLOUD, \"OTA finish fail\"); } } OPL_LOG_INFO(CLOUD, \"download result = %d\", i8Ret); // close http connection httpclient_close(&g_tCloudOtaHttpClient); free(buf); buf = NULL; return i8Ret; }","title":"OTA via WI-FI"},{"location":"application-guide/ota.html#how-to","text":"How to execute OTA via WI-FI in a single task Cloud_OtaHttpDownload is a single task to execute \"OTA via WI-FI\" process Apply httpclient_connect to connect http server Apply OTA_CurrentVersionGet Get current OTA firmware version via OTA Manager Apply _Cloud_OtaHttpRetrieveGet to retrieve raw data of new firmware from the cloud If retrieving sucessfully, apply OTA_UpgradeFinish to complete OTA via OTA Manager Apply httpclient_close to close http connection","title":"How To..."},{"location":"application-guide/project_config.html","text":"Project Configuration There are two configuration concepts qd_config.h and qd_module.h in this topic. In qd_config, we help developers classify some system configurations, among which power save is the key point. We use the concept of modularity to include the configuration method in qd_module. About 'qd_config.h' OPL Chip ID check #if defined(OPL1000_A2) || defined(OPL1000_A3) #else #error \"no define chip id in global definition in 'Preprocessor Symbols'\" #endif The chip id should be defined in Keil project file. RF power setting configuration #ifndef RF_CFG_DEF_PWR_SET #define RF_CFG_DEF_PWR_SET (RF_PWR_LVL_A0) #endif System configuration Set Power save mode #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (2) #endif There are three default types of SYS_CFG_PS_MODE that 0 means Low Power, 1 means Balance, 2 means Performance, else means user define if choosing user define. There are the following configurations that need to be manually configured by the developer if choosing else. Smart sleep enable #ifndef PS_ENABLED #define PS_ENABLED (1) #endif Mac layer sleep after got ip #ifndef PS_MAC_LAY_ENABLED #define PS_MAC_LAY_ENABLED (1) #endif Wi-Fi dtim period time #ifndef WM_DTIM_PERIOD_TIME #define WM_DTIM_PERIOD_TIME (3000) #endif Auto-connect retry interval #ifndef WM_AC_RETRY_INTVL_TBL static uint32_t g_u32WmAcRetryIntvlTbl[5] = { 30000, 30000, 60000, 60000, 900000, }; #define WM_AC_RETRY_INTVL_TBL (g_u32WmAcRetryIntvlTbl) #endif About 'qd_module.h' The developer can choose to use the desired module in qd_module.h Network Manager module If wanting to use Network Manager module to implement Wi-Fi process, the developer could set NM_ENABLED (1). At the same time, the developer must set Wi-Fi Manager module on that set WM_ENABLED (1). #ifndef NM_ENABLED #define NM_ENABLED (1) #endif The developer could only use Wi-Fi Manager module to implement Wi-Fi process if the developer don't use Network Manager module. Set NM_ENABLED (0) and WM_ENABLED (1). Wi-Fi Manager module #ifndef WM_ENABLED #define WM_ENABLED (1) #endif BLE Manager module If wanting to use BLE Manager module, the developer sets BM_ENABLED (1). #ifndef BM_ENABLED #define BM_ENABLED (1) #endif Time stamp module If wanting to use Time stamp module, the developer sets TIME_STMP_ENABLED (1). #ifndef TIME_STMP_ENABLED #define TIME_STMP_ENABLED (1) #endif Finite state machine If using Wi-Fi Manager module and BLE manager module, the developer must use Finite state machine module that set FSM_ENABLED (1). #ifndef FSM_ENABLED #define FSM_ENABLED (1) #endif","title":"Project Configuration"},{"location":"application-guide/project_config.html#project-configuration","text":"There are two configuration concepts qd_config.h and qd_module.h in this topic. In qd_config, we help developers classify some system configurations, among which power save is the key point. We use the concept of modularity to include the configuration method in qd_module.","title":"Project Configuration"},{"location":"application-guide/project_config.html#about-qd_configh","text":"OPL Chip ID check #if defined(OPL1000_A2) || defined(OPL1000_A3) #else #error \"no define chip id in global definition in 'Preprocessor Symbols'\" #endif The chip id should be defined in Keil project file. RF power setting configuration #ifndef RF_CFG_DEF_PWR_SET #define RF_CFG_DEF_PWR_SET (RF_PWR_LVL_A0) #endif System configuration Set Power save mode #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (2) #endif There are three default types of SYS_CFG_PS_MODE that 0 means Low Power, 1 means Balance, 2 means Performance, else means user define if choosing user define. There are the following configurations that need to be manually configured by the developer if choosing else. Smart sleep enable #ifndef PS_ENABLED #define PS_ENABLED (1) #endif Mac layer sleep after got ip #ifndef PS_MAC_LAY_ENABLED #define PS_MAC_LAY_ENABLED (1) #endif Wi-Fi dtim period time #ifndef WM_DTIM_PERIOD_TIME #define WM_DTIM_PERIOD_TIME (3000) #endif Auto-connect retry interval #ifndef WM_AC_RETRY_INTVL_TBL static uint32_t g_u32WmAcRetryIntvlTbl[5] = { 30000, 30000, 60000, 60000, 900000, }; #define WM_AC_RETRY_INTVL_TBL (g_u32WmAcRetryIntvlTbl) #endif","title":"About 'qd_config.h'"},{"location":"application-guide/project_config.html#about-qd_moduleh","text":"The developer can choose to use the desired module in qd_module.h Network Manager module If wanting to use Network Manager module to implement Wi-Fi process, the developer could set NM_ENABLED (1). At the same time, the developer must set Wi-Fi Manager module on that set WM_ENABLED (1). #ifndef NM_ENABLED #define NM_ENABLED (1) #endif The developer could only use Wi-Fi Manager module to implement Wi-Fi process if the developer don't use Network Manager module. Set NM_ENABLED (0) and WM_ENABLED (1). Wi-Fi Manager module #ifndef WM_ENABLED #define WM_ENABLED (1) #endif BLE Manager module If wanting to use BLE Manager module, the developer sets BM_ENABLED (1). #ifndef BM_ENABLED #define BM_ENABLED (1) #endif Time stamp module If wanting to use Time stamp module, the developer sets TIME_STMP_ENABLED (1). #ifndef TIME_STMP_ENABLED #define TIME_STMP_ENABLED (1) #endif Finite state machine If using Wi-Fi Manager module and BLE manager module, the developer must use Finite state machine module that set FSM_ENABLED (1). #ifndef FSM_ENABLED #define FSM_ENABLED (1) #endif","title":"About 'qd_module.h'"},{"location":"application-guide/pwr_measure.html","text":"Power Measure The OPL series chips provide power-saving functions to facilitate the development of more flexible and long-live IoT product. According to the development document Power-Saving-Introduction , OPL series chips provide the following power-saving types. Smart Sleep Timer Sleep Deep Sleep Due to the purpose of fast development, the QuickDev-Framework provides a mechanism called Power Mode which is based on Smart Sleep. Developer just set the power mode to configure the product as low-power / balance / performance device. The following setions descript the mechanism and demonstrate the power measure base on TCP_demo example. Power Mode As mentioned in section System Configuration , QuickDev-Framework provides a power mode selection for different application scenarios. There're 4 types selection that the user can select for different application / product type. Low-Power Mode Balance Mode Performance Mode User Define There are different configurations in each power mode selection, as defined by following parameters. PS_ENABLED - Smart Sleep enable PS_MAC_LAY_ENABLED - Wi-Fi MAC layer power save enable WM_DTIM_PERIOD_TIME - DTIM period time WM_AC_RETRY_INTVL_TBL - Wi-Fi auto-connect interval table Info The configure of Low-Power Mode , Balance Mode and Performance Mode had been set as a default setup defined in header files located at quick_dev/common/config/ps_config . Low-Power Mode The low-power mode configured for a low power consumption and long-live product type, it will be configured as a longer Skip DTIM period, and longer auto-connect interval for decreaseing core wakeup period for saving more power. To using this type, please configure the selection as following value in qd_config.h . #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (0) #endif Configuration Header file - quick_dev/common/config/ps_config/ps_config_lp.h Defines - // <o> PS_ENABLED - smart sleep enable #ifndef PS_ENABLED #define PS_ENABLED (1) #endif // <o> PS_MAC_LAY_ENABLED - mac layer sleep after got ip #ifndef PS_MAC_LAY_ENABLED #define PS_MAC_LAY_ENABLED (1) #endif // <o> WM_DTIM_PERIOD_TIME #ifndef WM_DTIM_PERIOD_TIME #define WM_DTIM_PERIOD_TIME (3000) #endif // <o> WM_AC_RETRY_INTVL_TBL - auto-connect in wifi manager retry interval table (ms) // <i> modify below array to fit with your needs #ifndef WM_AC_RETRY_INTVL_TBL static uint32_t g_u32WmAcRetryIntvlTbl[5] = { 30000, 30000, 60000, 60000, 900000, }; #define WM_AC_RETRY_INTVL_TBL (g_u32WmAcRetryIntvlTbl) #endif Balance Mode The balance mode configured for a large battery or a power-line with power supply types product, it would more care about the shorter Skip DTIM period and auto-connect interval, but also had a smart sleep activate on your application. To using this type, please configure the selection as following value in qd_config.h . #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (1) #endif Configuration Header file - quick_dev/common/config/ps_config/ps_config_bl.h Defines - // <o> PS_ENABLED - smart sleep enable #ifndef PS_ENABLED #define PS_ENABLED (1) #endif // <o> PS_MAC_LAY_ENABLED - mac layer sleep after got ip #ifndef PS_MAC_LAY_ENABLED #define PS_MAC_LAY_ENABLED (1) #endif // <o> WM_DTIM_PERIOD_TIME #ifndef WM_DTIM_PERIOD_TIME #define WM_DTIM_PERIOD_TIME (1000) #endif // <o> WM_AC_RETRY_INTVL_TBL - auto-connect in wifi manager retry interval table (ms) // <i> modify below array to fit with your needs #ifndef WM_AC_RETRY_INTVL_TBL static uint32_t g_u32WmAcRetryIntvlTbl[5] = { 30000, 30000, 30000, 60000, 60000, }; #define WM_AC_RETRY_INTVL_TBL (g_u32WmAcRetryIntvlTbl) #endif Performance Mode The performance mode configured for power-line with power supply type product, in this type selection the smart sleep will no-longer been activate, it will have a quick and better response of chip. To using this type, please configure the selection as following value in qd_config.h . #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (2) #endif Configuration Header file - quick_dev/common/config/ps_config/ps_config_pf.h Defines - // <o> PS_ENABLED - smart sleep enable #ifndef PS_ENABLED #define PS_ENABLED (0) #endif // <o> PS_MAC_LAY_ENABLED - mac layer sleep after got ip #ifndef PS_MAC_LAY_ENABLED #define PS_MAC_LAY_ENABLED (0) #endif // <o> WM_DTIM_PERIOD_TIME #ifndef WM_DTIM_PERIOD_TIME #define WM_DTIM_PERIOD_TIME (1000) #endif // <o> WM_AC_RETRY_INTVL_TBL - auto-connect in wifi manager retry interval table (ms) // <i> modify below array to fit with your needs #ifndef WM_AC_RETRY_INTVL_TBL static uint32_t g_u32WmAcRetryIntvlTbl[5] = { 5000, 5000, 5000, 10000, 10000, }; #define WM_AC_RETRY_INTVL_TBL (g_u32WmAcRetryIntvlTbl) #endif User Define The user-define mode is reserved for developer to configure all the setting items for customized application / product. To using this type, please configure the selection as following value in qd_config.h . #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (3) // or more then 3 #endif Info The user-define configuration is below the SYS_CFG_PS_MODE in qd_config.h . Measuring current consumption This section demonstrate the steps that how to measure the power consumption on Dev-Kit base on TCP_demo . Before to check on following document, it's recommend to see the Dev-Kit HDK document to understand the hardware of Dev-Kit. OPL1600-A3 Dev-Kit HDK : https://github.com/Opulinks-Tech/OPL1000-HDK OPL2500-A0 Dev-Kit HDK : https://github.com/Opulinks-Tech/OPL2500A0-HDK Wiring the Dev-Kit On measuring the power consumption, in below diagram shows how to wried the Dev-Kit with your power monitor / power meter, the focusing to setup the Dev-Kit is set the jumper to short the BAT pin and common pin at middle. This diagram present the connection with power monitor (supply function included). This diagram present the connection with power meter. Measure with TCP demo example Please check on TCP demo for more detail of this example. In following try out will guide you to measure the consumption in different situation. Note Before we go, we must set the Power Mode as Low-Power Mode to enable the Smart Sleep. Situation 1: Periodic post and keep-alive Switch on the periodic data post and set as 20 sec period time at qd_config.h in tcp_demo example. // <o> TCP_DEMO_PERI_POST_EN - enable periodic post data #ifndef TCP_DEMO_PERI_POST_EN #define TCP_DEMO_PERI_POST_EN (1) #endif // <o> TCP_DEMO_PERI_POST_INTERVAL - periodic post data interval time (ms) #ifndef TCP_DEMO_PERI_POST_INTERVAL #define TCP_DEMO_PERI_POST_INTERVAL (20000) #endif Set keep-alive interval as 120 sec at cloud_config.h locate in quick_dev/app_ref/cloud/tcp_cloud . // keep alive time : set 0 will disable the keep alive behavior #ifndef CLOUD_KEEP_ALIVE_TIME #define CLOUD_KEEP_ALIVE_TIME (120000) //ms #endif Then save and compiler the code, and download the binary into the device. After finish, open the TCP server with local network on your PC, the device will connect to server while the Network Up event indicate. When connected, the device will start periodic posting data to server and also trigger keep-alive message every 120 sec. In following screenshot, the consumption result of test arround 25min is near 0.16~0.18mA avg. in periodic data post and keep alive. Situation 2: Only keep-alive Base on situation 1 and only switch off the periodic data post at qd_config.h in tcp_demo example. // <o> TCP_DEMO_PERI_POST_EN - enable periodic post data #ifndef TCP_DEMO_PERI_POST_EN #define TCP_DEMO_PERI_POST_EN (0) #endif Follow the steps after the code changed at situation 1. When connected, the device will only trigger keep-alive message every 120 sec. In following screenshot, the consumption result of test arround 25min is near 0.11~0.13mA avg. in only keep alive. Situation 3: Idle Base on situation 2, we had close the periodic data post, now we try to disable the keep-alive interval to make the device only in TCP connected status but without any behavior. Set the keep-alive interval time as 0 to disable the keep-alive function at cloud_config.h locate in quick_dev/app_ref/cloud/tcp_cloud . // keep alive time : set 0 will disable the keep alive behavior #ifndef CLOUD_KEEP_ALIVE_TIME #define CLOUD_KEEP_ALIVE_TIME (0) //ms #endif Follow the steps after the code changed at situation 1. When connected, the device won't take any behavior and stay at idle status. In following screenshot, the consumption result of test arround 25min is near 0.09~0.10mA avg. in idle without any activity. On top situations, we'll get different average power consumption, and now on you can get the current by measuring in different examples or your application.","title":"Power Measure"},{"location":"application-guide/pwr_measure.html#power-measure","text":"The OPL series chips provide power-saving functions to facilitate the development of more flexible and long-live IoT product. According to the development document Power-Saving-Introduction , OPL series chips provide the following power-saving types. Smart Sleep Timer Sleep Deep Sleep Due to the purpose of fast development, the QuickDev-Framework provides a mechanism called Power Mode which is based on Smart Sleep. Developer just set the power mode to configure the product as low-power / balance / performance device. The following setions descript the mechanism and demonstrate the power measure base on TCP_demo example.","title":"Power Measure"},{"location":"application-guide/pwr_measure.html#power-mode","text":"As mentioned in section System Configuration , QuickDev-Framework provides a power mode selection for different application scenarios. There're 4 types selection that the user can select for different application / product type. Low-Power Mode Balance Mode Performance Mode User Define There are different configurations in each power mode selection, as defined by following parameters. PS_ENABLED - Smart Sleep enable PS_MAC_LAY_ENABLED - Wi-Fi MAC layer power save enable WM_DTIM_PERIOD_TIME - DTIM period time WM_AC_RETRY_INTVL_TBL - Wi-Fi auto-connect interval table Info The configure of Low-Power Mode , Balance Mode and Performance Mode had been set as a default setup defined in header files located at quick_dev/common/config/ps_config .","title":"Power Mode"},{"location":"application-guide/pwr_measure.html#low-power-mode","text":"The low-power mode configured for a low power consumption and long-live product type, it will be configured as a longer Skip DTIM period, and longer auto-connect interval for decreaseing core wakeup period for saving more power. To using this type, please configure the selection as following value in qd_config.h . #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (0) #endif","title":"Low-Power Mode"},{"location":"application-guide/pwr_measure.html#configuration","text":"","title":"Configuration"},{"location":"application-guide/pwr_measure.html#header-file-","text":"quick_dev/common/config/ps_config/ps_config_lp.h","title":"Header file -"},{"location":"application-guide/pwr_measure.html#defines-","text":"// <o> PS_ENABLED - smart sleep enable #ifndef PS_ENABLED #define PS_ENABLED (1) #endif // <o> PS_MAC_LAY_ENABLED - mac layer sleep after got ip #ifndef PS_MAC_LAY_ENABLED #define PS_MAC_LAY_ENABLED (1) #endif // <o> WM_DTIM_PERIOD_TIME #ifndef WM_DTIM_PERIOD_TIME #define WM_DTIM_PERIOD_TIME (3000) #endif // <o> WM_AC_RETRY_INTVL_TBL - auto-connect in wifi manager retry interval table (ms) // <i> modify below array to fit with your needs #ifndef WM_AC_RETRY_INTVL_TBL static uint32_t g_u32WmAcRetryIntvlTbl[5] = { 30000, 30000, 60000, 60000, 900000, }; #define WM_AC_RETRY_INTVL_TBL (g_u32WmAcRetryIntvlTbl) #endif","title":"Defines -"},{"location":"application-guide/pwr_measure.html#balance-mode","text":"The balance mode configured for a large battery or a power-line with power supply types product, it would more care about the shorter Skip DTIM period and auto-connect interval, but also had a smart sleep activate on your application. To using this type, please configure the selection as following value in qd_config.h . #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (1) #endif","title":"Balance Mode"},{"location":"application-guide/pwr_measure.html#configuration_1","text":"","title":"Configuration"},{"location":"application-guide/pwr_measure.html#header-file-_1","text":"quick_dev/common/config/ps_config/ps_config_bl.h","title":"Header file -"},{"location":"application-guide/pwr_measure.html#defines-_1","text":"// <o> PS_ENABLED - smart sleep enable #ifndef PS_ENABLED #define PS_ENABLED (1) #endif // <o> PS_MAC_LAY_ENABLED - mac layer sleep after got ip #ifndef PS_MAC_LAY_ENABLED #define PS_MAC_LAY_ENABLED (1) #endif // <o> WM_DTIM_PERIOD_TIME #ifndef WM_DTIM_PERIOD_TIME #define WM_DTIM_PERIOD_TIME (1000) #endif // <o> WM_AC_RETRY_INTVL_TBL - auto-connect in wifi manager retry interval table (ms) // <i> modify below array to fit with your needs #ifndef WM_AC_RETRY_INTVL_TBL static uint32_t g_u32WmAcRetryIntvlTbl[5] = { 30000, 30000, 30000, 60000, 60000, }; #define WM_AC_RETRY_INTVL_TBL (g_u32WmAcRetryIntvlTbl) #endif","title":"Defines -"},{"location":"application-guide/pwr_measure.html#performance-mode","text":"The performance mode configured for power-line with power supply type product, in this type selection the smart sleep will no-longer been activate, it will have a quick and better response of chip. To using this type, please configure the selection as following value in qd_config.h . #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (2) #endif","title":"Performance Mode"},{"location":"application-guide/pwr_measure.html#configuration_2","text":"","title":"Configuration"},{"location":"application-guide/pwr_measure.html#header-file-_2","text":"quick_dev/common/config/ps_config/ps_config_pf.h","title":"Header file -"},{"location":"application-guide/pwr_measure.html#defines-_2","text":"// <o> PS_ENABLED - smart sleep enable #ifndef PS_ENABLED #define PS_ENABLED (0) #endif // <o> PS_MAC_LAY_ENABLED - mac layer sleep after got ip #ifndef PS_MAC_LAY_ENABLED #define PS_MAC_LAY_ENABLED (0) #endif // <o> WM_DTIM_PERIOD_TIME #ifndef WM_DTIM_PERIOD_TIME #define WM_DTIM_PERIOD_TIME (1000) #endif // <o> WM_AC_RETRY_INTVL_TBL - auto-connect in wifi manager retry interval table (ms) // <i> modify below array to fit with your needs #ifndef WM_AC_RETRY_INTVL_TBL static uint32_t g_u32WmAcRetryIntvlTbl[5] = { 5000, 5000, 5000, 10000, 10000, }; #define WM_AC_RETRY_INTVL_TBL (g_u32WmAcRetryIntvlTbl) #endif","title":"Defines -"},{"location":"application-guide/pwr_measure.html#user-define","text":"The user-define mode is reserved for developer to configure all the setting items for customized application / product. To using this type, please configure the selection as following value in qd_config.h . #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (3) // or more then 3 #endif Info The user-define configuration is below the SYS_CFG_PS_MODE in qd_config.h .","title":"User Define"},{"location":"application-guide/pwr_measure.html#measuring-current-consumption","text":"This section demonstrate the steps that how to measure the power consumption on Dev-Kit base on TCP_demo . Before to check on following document, it's recommend to see the Dev-Kit HDK document to understand the hardware of Dev-Kit. OPL1600-A3 Dev-Kit HDK : https://github.com/Opulinks-Tech/OPL1000-HDK OPL2500-A0 Dev-Kit HDK : https://github.com/Opulinks-Tech/OPL2500A0-HDK","title":"Measuring current consumption"},{"location":"application-guide/pwr_measure.html#wiring-the-dev-kit","text":"On measuring the power consumption, in below diagram shows how to wried the Dev-Kit with your power monitor / power meter, the focusing to setup the Dev-Kit is set the jumper to short the BAT pin and common pin at middle. This diagram present the connection with power monitor (supply function included). This diagram present the connection with power meter.","title":"Wiring the Dev-Kit"},{"location":"application-guide/pwr_measure.html#measure-with-tcp-demo-example","text":"Please check on TCP demo for more detail of this example. In following try out will guide you to measure the consumption in different situation. Note Before we go, we must set the Power Mode as Low-Power Mode to enable the Smart Sleep.","title":"Measure with TCP demo example"},{"location":"application-guide/pwr_measure.html#situation-1-periodic-post-and-keep-alive","text":"Switch on the periodic data post and set as 20 sec period time at qd_config.h in tcp_demo example. // <o> TCP_DEMO_PERI_POST_EN - enable periodic post data #ifndef TCP_DEMO_PERI_POST_EN #define TCP_DEMO_PERI_POST_EN (1) #endif // <o> TCP_DEMO_PERI_POST_INTERVAL - periodic post data interval time (ms) #ifndef TCP_DEMO_PERI_POST_INTERVAL #define TCP_DEMO_PERI_POST_INTERVAL (20000) #endif Set keep-alive interval as 120 sec at cloud_config.h locate in quick_dev/app_ref/cloud/tcp_cloud . // keep alive time : set 0 will disable the keep alive behavior #ifndef CLOUD_KEEP_ALIVE_TIME #define CLOUD_KEEP_ALIVE_TIME (120000) //ms #endif Then save and compiler the code, and download the binary into the device. After finish, open the TCP server with local network on your PC, the device will connect to server while the Network Up event indicate. When connected, the device will start periodic posting data to server and also trigger keep-alive message every 120 sec. In following screenshot, the consumption result of test arround 25min is near 0.16~0.18mA avg. in periodic data post and keep alive.","title":"Situation 1: Periodic post and keep-alive"},{"location":"application-guide/pwr_measure.html#situation-2-only-keep-alive","text":"Base on situation 1 and only switch off the periodic data post at qd_config.h in tcp_demo example. // <o> TCP_DEMO_PERI_POST_EN - enable periodic post data #ifndef TCP_DEMO_PERI_POST_EN #define TCP_DEMO_PERI_POST_EN (0) #endif Follow the steps after the code changed at situation 1. When connected, the device will only trigger keep-alive message every 120 sec. In following screenshot, the consumption result of test arround 25min is near 0.11~0.13mA avg. in only keep alive.","title":"Situation 2: Only keep-alive"},{"location":"application-guide/pwr_measure.html#situation-3-idle","text":"Base on situation 2, we had close the periodic data post, now we try to disable the keep-alive interval to make the device only in TCP connected status but without any behavior. Set the keep-alive interval time as 0 to disable the keep-alive function at cloud_config.h locate in quick_dev/app_ref/cloud/tcp_cloud . // keep alive time : set 0 will disable the keep alive behavior #ifndef CLOUD_KEEP_ALIVE_TIME #define CLOUD_KEEP_ALIVE_TIME (0) //ms #endif Follow the steps after the code changed at situation 1. When connected, the device won't take any behavior and stay at idle status. In following screenshot, the consumption result of test arround 25min is near 0.09~0.10mA avg. in idle without any activity. On top situations, we'll get different average power consumption, and now on you can get the current by measuring in different examples or your application.","title":"Situation 3: Idle"},{"location":"application-guide/wifi.html","text":"WI-FI Descript of WI-FI manager & Network Manager & Auto-Connect Network Manager Network manager can handling wifi manager & auto-connect interactive behavior to let user only care about triggering WI-FI scan request and connect request. Info To see the usage example of Network Manager, can check in qd_app in examples\\start_up\\ folder. The network manager initiation will also initialize the wifi manager and auto-connect. It's not necessary to initiate again in application Initialize Before using the network manager, please follow below steps to initiate. Step 1. Enable network manager #define WM_ENABLED (1) #define NM_ENABLED (1) #define AC_ENABLED (1) The definition been defined in qd_config.h in sys_config folder. Warning WM_ENABLED and AC_ENABLED are both required if using network manager. (The AC_ENABLED definition will be force to set as true while NM_ENABLED been set.) Step 2. Add related files in Keil project Step 3. Register callback and init Add below program in app_main.c void APP_NmUnsolicitedCallback(T_NmUslctdEvtType tEvtType, uint8_t *pu8Data, uint32_t u32DataLen) { // tEvtType refer to net_mngr_api.h switch(tEvtType) { case NM_USLCTD_EVT_NETWORK_UP: { // wifi connected & got ip event break; } case NM_USLCTD_EVT_NETWORK_DOWN: { // wifi disconnect event break; } case NM_USLCTD_EVT_NETWORK_RESET: { // wifi reset event break; } default: { // should not be here break; } } } void APP_NetInit(void) { // Network manager initialize (auto-connect enable) APP_NmInit(true, &APP_NmUnsolicitedCallback); // user implement } The first parameter of APP_NmInit() is to enable/disable auto-connect at started. If set as true - the auto-connect will directly be funtional in sequence. If set as false - the auto-connect won't active. Info The APP_NetInit() function create by default in app_main.c , it's for developer to fill the network related init function in it. Unsolicited callback & Indicate callback There're two types of callback function pointer can be assign to Network manager Unsolicited callback - Used for recving unsolicited events from network manager, will be called in network up (Wi-Fi connected & IP got)/ network down/ WI-FI reset. Info network up event represents to WI-FI connected and got dhcp ip Unsolicited callback carried... Event, Result, Data & DataLens (Descript) Indicate callback - Used for getting solicited events of each request to send to network manager (such as scan_req). Indicate callback carried... Result (Descript) Info Unsolicited callback & Indicate callback prototype located in nm_mngr_api.h WI-FI Manager WI-FI manager provide a easy way to control WI-FI. Info Network manager runs base on WI-FI manager, so if using the network manager the WI-FI manager will be directly initiate at network manager initiation. Initialize Before using the WI-FI manager, please follow below steps to initiate. Step 1. Enable WI-FI manager #define WM_ENABLED (1) The definition been defined in qd_module.h in sys_config folder. Step 2. Add related files in Keil project Step 3. Register callback and init Add below program in app_main.c void APP_WmUnsolicitedCallback(T_WmUslctedEvtType tEvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { // tEvtType refer to wifi_mngr_api.h switch(tEvtType) { case USLCTED_CB_EVT_WIFI_UP: { // wifi connected event break; } case USLCTED_CB_EVT_WIFI_DOWN: { // wifi disconnect event break; } case USLCTED_CB_EVT_WIFI_RESET: { // wifi reset event break; } case USLCTED_CB_EVT_GOT_IP: { // wifi got ip break; } } } void APP_WifiInitDoneIndCallback(T_OplErr tEvtRst) { APP_SendMessage(APP_EVT_WIFI_INIT_DONE, (uint8_t*)&tEvtRst, sizeof(T_OplErr)); } void APP_NetInit(void) { // register Wi-Fi unsolicited callback if(OPL_OK != Opl_Wifi_Uslctd_CB_Reg(APP_WmUnsolicitedCallback)) { OPL_LOG_ERRO(APP, \"Wi-Fi unsolicited callback regist fail\"); } // Wi-Fi manager initialize Opl_Wifi_Init_Req(APP_WifiInitDoneIndCallback); // user implement } Info The APP_NetInit() function create by default in app_main.c , it's for developer to fill the network related init function in it. Unsolicited callback & Indicate callback There're two types of callback function pointer can be assign to WI-FI manager Unsolicited callback - Used for recving unsolicited events from WI-FI, will happens in WI-FI connected/ disconnected/ reset/ got ip. Unsolicited callback carried... Event, Result, Data & DataLens (Descript) Indicate callback - Used for getting solicited events of each request to send to WI-FI manager (such as scan_req). Indicate callback carried... Result (Descript) Info Unsolicited callback & Indicate callback prototype located in wifi_mngr_api.h Auto-Connect The auto-connect will do automatically connect to stored AP while the WI-FI connection offline, and will periodcially to retry till connected or been disable. Initialize Enable auto-connect and add related file into Keil project #define WM_ENABLED (1) #define AC_ENABLED (1) Info The auto-Connect will be init while initating WI-FI manager. Usage See in API reference How To... Network Manager Network Manager provides mechanism to configure and monitor Wi-Fi networking. We strongly recommend applying Network Manager due to the Network Manager could make the process more robustly. Once the Network Manager initialize done, developer could start to perform the network process via Network Manager How to perform Wi-Fi scan WI-FI scan request via Network Manager T_OplErr APP_NmWifiScanReq(T_NmScanDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that scan is done. After receiving, application can retrieve the scan result and trigger the following Wi-Fi connection operation. Retrieve WI-FI scan result T_OplErr WM_WaScanListGet(wifi_scan_list_t *ptScanList) This structure ptScanList defines the list of scanned APs with their corresponding information. How to perform Wi-Fi connection according to the scan result WI-FI connect via Network Manager T_OplErr APP_NmWifiCnctReq(T_NmWifiCnctConfig *ptWmWifiCnctConfig, T_NmCnctIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that connect is done. Developer could receive unsolicited events from Network Manager, including connected/ disconnected/ reset/ got ip. Configurate connect configuration ptWmWifiCnctConfig with scan result ptScanList typedef struct S_NmWifiCnctConfig { uint8_t u8aBssid[WIFI_MAC_ADDRESS_LENGTH]; // The MAC address of the target AP. uint8_t u8aSsid[WIFI_MAX_LENGTH_OF_SSID]; // The SSID of the target AP. uint8_t u8SsidLen; uint8_t u8aPwd[WIFI_LENGTH_PASSPHRASE]; // The password of the target AP. uint8_t u8PwdLen; // The length of the password. If the length is 64, the password is regarded as PMK. uint8_t u8Timeout; // Connect timeout } T_NmWifiCnctConfig; WI-FI Manager It is not necessary to access Wi-Fi Manager if Network Manager is enabled. However, developer can disable Network Manager and apply Wi-Fi Manager to perform network process directly. Before performing any Wi-Fi operation, developer should trigger Wi-Fi initial first. How to perform Wi-Fi initiate Wi-Fi initiate via Wi-Fi manager T_OplErr Opl_Wifi_Init_Req(T_WaInitDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that initiate is done. After receiving, application can trigger the following Wi-Fi operation. Both user application and the auto-connect module might trigger Wi-Fi operation. The user application should turn off auto-connect module before trigger any Wi-Fi operation. WI-FI auto connect disable request T_OplErr Opl_Wifi_AC_Disable_Req(bool blActDisconnect, T_AcDisableIndCbFp fpIndCb) If blActDisconnect is true that disable auto-connect module. Inside the callback fpIndCb , developer can send message to inform application Wi-Fi auto-connect disable done. Once user Wi-Fi operation completed, application can turn on auto-connect module again. WI-FI auto connect enable request T_OplErr Opl_Wifi_AC_Enable_Req(T_AcEnableIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application Wi-Fi auto-connect enable done. How to perform Wi-Fi scan WI-FI scan request via Wi-Fi Manager T_OplErr Opl_Wifi_Scan_Req(wifi_scan_config_t *ptWifiScanConfig, T_WaScanDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that scan is done. After receiving, application can retrieve the scan result and trigger the following Wi-Fi connection operation. Configurate scan configuration ptWifiScanConfig typedef struct { uint8_t *ssid; /**< SSID of AP */ uint8_t *bssid; /**< MAC address of AP, point to array[WIFI_MAC_ADDRESS_LENGTH] */ uint8_t channel; /**< channel, scan the specific channel */ bool show_hidden; /**< enable to scan AP whose SSID is hidden */ wifi_scan_type_t scan_type; /**< scan type, active or passive */ wifi_scan_time_t scan_time; /**< scan time per channel */ } wifi_scan_config_t; The ssid and bssid could be empty if developer want to scan global APs. Retrieve WI-FI scan result T_OplErr WM_WaScanListGet(wifi_scan_list_t *ptScanList) This structure ptScanList defines the list of scanned APs with their corresponding information. How to perform Wi-Fi connect according to the scan result WI-FI connect request via WI-FI Manager T_OplErr Opl_Wifi_Conn_Req(T_WmConnConfig *ptWifiConnConfig, T_WaConnectIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that connect is done. Developer could receive unsolicited events from Wi-Fi, including connected/ disconnected/ reset/ got ip. Configurate connect configuration ptWifiConnConfig with scan result ptScanList typedef struct S_WmConnConfig { uint8_t ssid[WIFI_MAX_LENGTH_OF_SSID]; // The SSID of the target AP. uint8_t ssid_length; // The length of the SSID. uint8_t bssid[WIFI_MAC_ADDRESS_LENGTH]; // The MAC address of the target AP. uint8_t password[WIFI_LENGTH_PASSPHRASE]; // The password of the target AP. uint8_t password_length; // The length of the password. If the length is 64, the password is regarded as PMK. } __attribute__((packed)) T_WmConnConfig;","title":"WI-FI"},{"location":"application-guide/wifi.html#wi-fi","text":"Descript of WI-FI manager & Network Manager & Auto-Connect","title":"WI-FI"},{"location":"application-guide/wifi.html#network-manager","text":"Network manager can handling wifi manager & auto-connect interactive behavior to let user only care about triggering WI-FI scan request and connect request. Info To see the usage example of Network Manager, can check in qd_app in examples\\start_up\\ folder. The network manager initiation will also initialize the wifi manager and auto-connect. It's not necessary to initiate again in application","title":"Network Manager"},{"location":"application-guide/wifi.html#initialize","text":"Before using the network manager, please follow below steps to initiate.","title":"Initialize"},{"location":"application-guide/wifi.html#step-1-enable-network-manager","text":"#define WM_ENABLED (1) #define NM_ENABLED (1) #define AC_ENABLED (1) The definition been defined in qd_config.h in sys_config folder. Warning WM_ENABLED and AC_ENABLED are both required if using network manager. (The AC_ENABLED definition will be force to set as true while NM_ENABLED been set.)","title":"Step 1. Enable network manager"},{"location":"application-guide/wifi.html#step-2-add-related-files-in-keil-project","text":"","title":"Step 2. Add related files in Keil project"},{"location":"application-guide/wifi.html#step-3-register-callback-and-init","text":"Add below program in app_main.c void APP_NmUnsolicitedCallback(T_NmUslctdEvtType tEvtType, uint8_t *pu8Data, uint32_t u32DataLen) { // tEvtType refer to net_mngr_api.h switch(tEvtType) { case NM_USLCTD_EVT_NETWORK_UP: { // wifi connected & got ip event break; } case NM_USLCTD_EVT_NETWORK_DOWN: { // wifi disconnect event break; } case NM_USLCTD_EVT_NETWORK_RESET: { // wifi reset event break; } default: { // should not be here break; } } } void APP_NetInit(void) { // Network manager initialize (auto-connect enable) APP_NmInit(true, &APP_NmUnsolicitedCallback); // user implement } The first parameter of APP_NmInit() is to enable/disable auto-connect at started. If set as true - the auto-connect will directly be funtional in sequence. If set as false - the auto-connect won't active. Info The APP_NetInit() function create by default in app_main.c , it's for developer to fill the network related init function in it.","title":"Step 3. Register callback and init"},{"location":"application-guide/wifi.html#unsolicited-callback-indicate-callback","text":"There're two types of callback function pointer can be assign to Network manager Unsolicited callback - Used for recving unsolicited events from network manager, will be called in network up (Wi-Fi connected & IP got)/ network down/ WI-FI reset. Info network up event represents to WI-FI connected and got dhcp ip Unsolicited callback carried... Event, Result, Data & DataLens (Descript) Indicate callback - Used for getting solicited events of each request to send to network manager (such as scan_req). Indicate callback carried... Result (Descript) Info Unsolicited callback & Indicate callback prototype located in nm_mngr_api.h","title":"Unsolicited callback &amp; Indicate callback"},{"location":"application-guide/wifi.html#wi-fi-manager","text":"WI-FI manager provide a easy way to control WI-FI. Info Network manager runs base on WI-FI manager, so if using the network manager the WI-FI manager will be directly initiate at network manager initiation.","title":"WI-FI Manager"},{"location":"application-guide/wifi.html#initialize_1","text":"Before using the WI-FI manager, please follow below steps to initiate.","title":"Initialize"},{"location":"application-guide/wifi.html#step-1-enable-wi-fi-manager","text":"#define WM_ENABLED (1) The definition been defined in qd_module.h in sys_config folder.","title":"Step 1. Enable WI-FI manager"},{"location":"application-guide/wifi.html#step-2-add-related-files-in-keil-project_1","text":"","title":"Step 2. Add related files in Keil project"},{"location":"application-guide/wifi.html#step-3-register-callback-and-init_1","text":"Add below program in app_main.c void APP_WmUnsolicitedCallback(T_WmUslctedEvtType tEvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { // tEvtType refer to wifi_mngr_api.h switch(tEvtType) { case USLCTED_CB_EVT_WIFI_UP: { // wifi connected event break; } case USLCTED_CB_EVT_WIFI_DOWN: { // wifi disconnect event break; } case USLCTED_CB_EVT_WIFI_RESET: { // wifi reset event break; } case USLCTED_CB_EVT_GOT_IP: { // wifi got ip break; } } } void APP_WifiInitDoneIndCallback(T_OplErr tEvtRst) { APP_SendMessage(APP_EVT_WIFI_INIT_DONE, (uint8_t*)&tEvtRst, sizeof(T_OplErr)); } void APP_NetInit(void) { // register Wi-Fi unsolicited callback if(OPL_OK != Opl_Wifi_Uslctd_CB_Reg(APP_WmUnsolicitedCallback)) { OPL_LOG_ERRO(APP, \"Wi-Fi unsolicited callback regist fail\"); } // Wi-Fi manager initialize Opl_Wifi_Init_Req(APP_WifiInitDoneIndCallback); // user implement } Info The APP_NetInit() function create by default in app_main.c , it's for developer to fill the network related init function in it.","title":"Step 3. Register callback and init"},{"location":"application-guide/wifi.html#unsolicited-callback-indicate-callback_1","text":"There're two types of callback function pointer can be assign to WI-FI manager Unsolicited callback - Used for recving unsolicited events from WI-FI, will happens in WI-FI connected/ disconnected/ reset/ got ip. Unsolicited callback carried... Event, Result, Data & DataLens (Descript) Indicate callback - Used for getting solicited events of each request to send to WI-FI manager (such as scan_req). Indicate callback carried... Result (Descript) Info Unsolicited callback & Indicate callback prototype located in wifi_mngr_api.h","title":"Unsolicited callback &amp; Indicate callback"},{"location":"application-guide/wifi.html#auto-connect","text":"The auto-connect will do automatically connect to stored AP while the WI-FI connection offline, and will periodcially to retry till connected or been disable.","title":"Auto-Connect"},{"location":"application-guide/wifi.html#initialize_2","text":"Enable auto-connect and add related file into Keil project #define WM_ENABLED (1) #define AC_ENABLED (1) Info The auto-Connect will be init while initating WI-FI manager.","title":"Initialize"},{"location":"application-guide/wifi.html#usage","text":"See in API reference","title":"Usage"},{"location":"application-guide/wifi.html#how-to","text":"","title":"How To..."},{"location":"application-guide/wifi.html#network-manager_1","text":"Network Manager provides mechanism to configure and monitor Wi-Fi networking. We strongly recommend applying Network Manager due to the Network Manager could make the process more robustly. Once the Network Manager initialize done, developer could start to perform the network process via Network Manager","title":"Network Manager"},{"location":"application-guide/wifi.html#how-to-perform-wi-fi-scan","text":"WI-FI scan request via Network Manager T_OplErr APP_NmWifiScanReq(T_NmScanDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that scan is done. After receiving, application can retrieve the scan result and trigger the following Wi-Fi connection operation. Retrieve WI-FI scan result T_OplErr WM_WaScanListGet(wifi_scan_list_t *ptScanList) This structure ptScanList defines the list of scanned APs with their corresponding information.","title":"How to perform Wi-Fi scan"},{"location":"application-guide/wifi.html#how-to-perform-wi-fi-connection-according-to-the-scan-result","text":"WI-FI connect via Network Manager T_OplErr APP_NmWifiCnctReq(T_NmWifiCnctConfig *ptWmWifiCnctConfig, T_NmCnctIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that connect is done. Developer could receive unsolicited events from Network Manager, including connected/ disconnected/ reset/ got ip. Configurate connect configuration ptWmWifiCnctConfig with scan result ptScanList typedef struct S_NmWifiCnctConfig { uint8_t u8aBssid[WIFI_MAC_ADDRESS_LENGTH]; // The MAC address of the target AP. uint8_t u8aSsid[WIFI_MAX_LENGTH_OF_SSID]; // The SSID of the target AP. uint8_t u8SsidLen; uint8_t u8aPwd[WIFI_LENGTH_PASSPHRASE]; // The password of the target AP. uint8_t u8PwdLen; // The length of the password. If the length is 64, the password is regarded as PMK. uint8_t u8Timeout; // Connect timeout } T_NmWifiCnctConfig;","title":"How to perform Wi-Fi connection according to the scan result"},{"location":"application-guide/wifi.html#wi-fi-manager_1","text":"It is not necessary to access Wi-Fi Manager if Network Manager is enabled. However, developer can disable Network Manager and apply Wi-Fi Manager to perform network process directly. Before performing any Wi-Fi operation, developer should trigger Wi-Fi initial first.","title":"WI-FI Manager"},{"location":"application-guide/wifi.html#how-to-perform-wi-fi-initiate","text":"Wi-Fi initiate via Wi-Fi manager T_OplErr Opl_Wifi_Init_Req(T_WaInitDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that initiate is done. After receiving, application can trigger the following Wi-Fi operation. Both user application and the auto-connect module might trigger Wi-Fi operation. The user application should turn off auto-connect module before trigger any Wi-Fi operation. WI-FI auto connect disable request T_OplErr Opl_Wifi_AC_Disable_Req(bool blActDisconnect, T_AcDisableIndCbFp fpIndCb) If blActDisconnect is true that disable auto-connect module. Inside the callback fpIndCb , developer can send message to inform application Wi-Fi auto-connect disable done. Once user Wi-Fi operation completed, application can turn on auto-connect module again. WI-FI auto connect enable request T_OplErr Opl_Wifi_AC_Enable_Req(T_AcEnableIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application Wi-Fi auto-connect enable done.","title":"How to perform Wi-Fi initiate"},{"location":"application-guide/wifi.html#how-to-perform-wi-fi-scan_1","text":"WI-FI scan request via Wi-Fi Manager T_OplErr Opl_Wifi_Scan_Req(wifi_scan_config_t *ptWifiScanConfig, T_WaScanDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that scan is done. After receiving, application can retrieve the scan result and trigger the following Wi-Fi connection operation. Configurate scan configuration ptWifiScanConfig typedef struct { uint8_t *ssid; /**< SSID of AP */ uint8_t *bssid; /**< MAC address of AP, point to array[WIFI_MAC_ADDRESS_LENGTH] */ uint8_t channel; /**< channel, scan the specific channel */ bool show_hidden; /**< enable to scan AP whose SSID is hidden */ wifi_scan_type_t scan_type; /**< scan type, active or passive */ wifi_scan_time_t scan_time; /**< scan time per channel */ } wifi_scan_config_t; The ssid and bssid could be empty if developer want to scan global APs. Retrieve WI-FI scan result T_OplErr WM_WaScanListGet(wifi_scan_list_t *ptScanList) This structure ptScanList defines the list of scanned APs with their corresponding information.","title":"How to perform Wi-Fi scan"},{"location":"application-guide/wifi.html#how-to-perform-wi-fi-connect-according-to-the-scan-result","text":"WI-FI connect request via WI-FI Manager T_OplErr Opl_Wifi_Conn_Req(T_WmConnConfig *ptWifiConnConfig, T_WaConnectIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that connect is done. Developer could receive unsolicited events from Wi-Fi, including connected/ disconnected/ reset/ got ip. Configurate connect configuration ptWifiConnConfig with scan result ptScanList typedef struct S_WmConnConfig { uint8_t ssid[WIFI_MAX_LENGTH_OF_SSID]; // The SSID of the target AP. uint8_t ssid_length; // The length of the SSID. uint8_t bssid[WIFI_MAC_ADDRESS_LENGTH]; // The MAC address of the target AP. uint8_t password[WIFI_LENGTH_PASSPHRASE]; // The password of the target AP. uint8_t password_length; // The length of the password. If the length is 64, the password is regarded as PMK. } __attribute__((packed)) T_WmConnConfig;","title":"How to perform Wi-Fi connect according to the scan result"},{"location":"application-guide/wifi_provision_via_ble.html","text":"WI-FI provision via BLE The advantage of dual-core chip (OPL series), QuickDev-Framework provide a process to provision Wi-Fi credentials of the Home AP via the Bluetooth low energy (BLE). This setion can help the developer to quickly understand and implement the protocol into the application. This block diagram introduces the architecture of the provision Wi-Fi credentials via BLE. The phone (BLE central) will transmitting the required message to the device. When the device received the message, it will process the Wi-Fi connection base on the given information. Opulinks also provide a reference code-base for Phone APP, the front-end developer can use the needed code-base to enhance on their project/product. Android APP : IOS APP : WeChat mini APP : Provision Process QuickDev-Framework had provided the Wi-Fi provision via BLE protocol, for a quick look to the example which can demonstrate the Wi-Fi provision via BLE protocol, please check on QD_APP section. In below diagram, it present a simplify steps that how's the provision done. When the phone (BLE central) wants to provision the Wi-Fi credential and connect to AP, the phone (BLE central) will send the command and required message to the device, e.g. Wi-Fi scan request or Wi-Fi connect request. And the device is responsible to receive and parsing the required message, then progress the Network manager to processing according to different events. While Network manager had done with indicate or unsolicited callback returns, then the device will transit the corresponding response or result to the phone (BLE central) for notify the status. The focusing of provision process is to create a BLE data command list to letting the phone (BLE central) and the device can recognize the data and handling in such. OPL Service OPL service is one of the profile service collection in BLE which designed by Opulinks that including the Wi-Fi provision command & handler needed. Info To understand the BLE manager and BLE service can refer to BluetoothLE The OPL service UUID defined in quick_dev/app_ref/ble_data_prot/opl_data/opl_svc.h Service/Characteristic UUID OPL service 0xAAAA DATA IN character 0xBBB0 DATA OUT character 0xBBB1 Initialize To using this service on your application, please follow in below items. Initialize the OPL service in your application Add OPL_Svc_Init() in app_main.c void APP_BleInit(void) { // assign unsolicited callback function Opl_Ble_Uslctd_CB_Reg(&APP_BleUnsolicitedCallback); // register service GAP_Svc_Init(); GATT_Svc_Init(); // register opl service OPL_Svc_Init(); // <- initialize OPL service // initialize the ble manager (auto-adv) Opl_Ble_Init_Req(true); // user implement } Generate a data passthrough When the data received, the OPL_SVC_DATA_IN characteristic contents in OPL service will execute a context switch to passing the received data from BLE manager to host application, so we need to create a catcher on application side, and let it process the data parsing and progress. Add the APP_EVT_BLE_DATA_IND event and handler in app_main.c . static T_AppEvtHandlerTbl g_tAppEvtHandlerTbl[] = { ... {APP_EVT_BLE_DATA_IND, APP_EvtHandler_BleDataInd}, ... {0xFFFFFFFF, NULL}, }; Then add OPL_DataRecvHandler() to let the handler do parsing and progress. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); } At final step, we must enable the protocol which defined in `qd_module.h\" //========================================================== // <h> OPL Data protocol //========================================================== // <e> OPL_DATA_ENABLED - Opulinks BLE WI-FI data protocol //========================================================== #ifndef OPL_DATA_ENABLED #define OPL_DATA_ENABLED (1) #endif And that's the wrap, the Wi-Fi provision via BLE function has been activated in your application. It's recommend to using our standard phone APP by searching \"Opulinks Wireless Utilities\" at APP store to try with. How to... How to create an user defined service (e.g. quick_dev\\app_ref\\ble_data_prot\\opl_svc.c ) in BLE Manager Please refer to BluetoothLE How to receive BLE data in and then export to BLE Application in application Create a gatt dispatch handler (e.g. OPL_Svc_GattDispatchHandler() ) in user defined service static T_OplErr OPL_Svc_GattDispatchHandler(MESSAGEID tId, MESSAGE tMsg) { switch(tId) { case LE_GATT_MSG_ACCESS_READ_IND: { OPL_Svc_GattDispatchReadHandler((LE_GATT_MSG_ACCESS_READ_IND_T *)tMsg); break; } case LE_GATT_MSG_ACCESS_WRITE_IND: { OPL_Svc_GattDispatchWriteHandler((LE_GATT_MSG_ACCESS_WRITE_IND_T *)tMsg); break; } case LE_GATT_MSG_NOTIFY_CFM: { Opl_Ble_Send_Message(OPL_SVC_EVT_SEND_TO_PEER_CFM, NULL, 0, 0); break; } default: { return OPL_ERR_CASE_INVALID; } } return OPL_OK; } This example is receiving LE_GATT_MSG_ACCESS_WRITE_IND event to handle BLE data via OPL_Svc_GattDispatchWriteHandler() tatic void OPL_Svc_GattDispatchWriteHandler(LE_GATT_MSG_ACCESS_WRITE_IND_T *ind) { // process the write access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tOplSvcHandle.ptSvcDef->startHdl; switch(u16AttrId) { case OPL_SVC_IDX_DATA_IN_VAL: { APP_SendMessage(APP_EVT_BLE_DATA_IND, ind->pVal, ind->len); break; } case OPL_SVC_IDX_DATA_OUT_CFG: { uint16_t u16Enable = *((uint16_t *)ind->pVal); if ((ind->len == 2) && (u16Enable <= 1)) { LeGattChangeAttrVal(g_tOplSvcHandle.ptSvcDef, OPL_SVC_IDX_DATA_OUT_CFG, sizeof(u16Enable), &u16Enable); } else { u8AttErr = LE_ATT_ERR_INVALID_ATTR_VALUE_LEN; } break; } default: { u8AttErr = LE_ATT_ERR_WRITE_NOT_PERMITTED; break; } } If receiving OPL_SVC_IDX_DATA_IN_VAL , OPL_Svc_GattDispatchWriteHandler() could send BLE data to application via APP_SendMessage() In application, developer could create a function (e.g. APP_EvtHandler_BleDataInd() ) to send BLE data to BLE Application. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); } How to handle Wi-Fi provision message via BLE in BLE Application BLE Application is responsible for parsing the messages from BLE, and then processing these events by category. Wi-Fi provision messages include Wi-Fi scan, Wi-Fi connect, Wi-Fi disconnect, Wi-Fi reconnect, read device Wi-Fi information, write Wi-Fi device information, get device Wi-Fi status and reset Wi-Fi. It is a BLE Application event handler table g_tOplDataEventHandlerTbl to handle these events. static T_OplDataEventTable g_tOplDataEventHandlerTbl[] = { {OPL_DATA_REQ_SCAN, OPL_DataProtocol_Scan}, {OPL_DATA_REQ_CONNECT, OPL_DataProtocol_Connect}, {OPL_DATA_REQ_DISCONNECT, OPL_DataProtocol_Disconnect}, {OPL_DATA_REQ_RECONNECT, OPL_DataProtocol_Reconnect}, {OPL_DATA_REQ_READ_DEVICE_INFO, OPL_DataProtocol_ReadDeviceInfo}, {OPL_DATA_REQ_WRITE_DEVICE_INFO, OPL_DataProtocol_WriteDeviceInfo}, {OPL_DATA_REQ_WIFI_STATUS, OPL_DataProtocol_WifiStatus}, {OPL_DATA_REQ_RESET, OPL_DataProtocol_Reset}, For example, if receiving OPL_DATA_REQ_SCAN , OPL_DataProtocol_Scan handler will send Wi-Fi scan message to Network Manager to execute Wi-Fi scan. static void OPL_DataProtocol_Scan(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_SCAN\"); // reset connection config table memset(&g_tOplDataConnCfg, 0, sizeof(T_OplDataConnCfg)); g_tOplDataConnCfg.u8ConnectType = OPL_DATA_CONN_TYPE_BSSID; // trigger scan request APP_NmWifiScanReq(OPL_DataHandler_WifiScanDoneIndCb); } How to respnose Wi-Fi process result to phone BLE Application send Wi-Fi provision message to Network Manager, and then Network Manager will create a callback function to handle indicate callback. For example, if Wi-Fi scan done, the Wi-FI scan done callback OPL_DataHandler_WifiScanDoneIndCb will follow up on scan done. void OPL_DataHandler_WifiScanDoneIndCb(T_OplErr tEvtRst) { OPL_LOG_DEBG(OPL, \"Wifi scan done ind %d\", tEvtRst); if(OPL_DATA_CONN_TYPE_BSSID == g_tOplDataConnCfg.u8ConnectType) { // CK_DATA_REQ_SCAN cmd, just do report scan list _OPL_DataHandler_SendScanReport(); OPL_DataSendResponse(OPL_DATA_RSP_SCAN_END, 0); } } _OPL_DataHandler_SendScanReport will obtain the information of APs via Wi-Fi Manager in the environment, and sort out the AP list. static int _OPL_DataHandler_SendScanReport(void) { wifi_scan_info_t *pstAPList = NULL; wifi_auto_connect_info_t *info = NULL; T_WmScanInfo *pstWifiAPList = NULL; uint8_t u8APPAutoConnectGetApNum = 0; // uint8_t u8IsUpdate = false; uint16_t u16apCount = 0; int32_t i = 0, j = 0; // TODO: get ap number Opl_Wifi_ApNum_Get(&u16apCount); OPL_LOG_INFO(OPL, \"AP num = %d\", u16apCount); pstAPList = (wifi_scan_info_t *)malloc(sizeof(wifi_scan_info_t) * u16apCount); // TODO: get ap record Opl_Wifi_ApRecord_Get(&u16apCount, pstAPList); pstWifiAPList = (T_WmScanInfo *)malloc(sizeof(T_WmScanInfo) * u16apCount); memset(pstWifiAPList , 0 , sizeof(T_WmScanInfo) * u16apCount); // TODO: get auto connect ap number Opl_Wifi_AutoConnectApNum_Get(&u8APPAutoConnectGetApNum); if (u8APPAutoConnectGetApNum) { info = (wifi_auto_connect_info_t *)malloc(sizeof(wifi_auto_connect_info_t) * u8APPAutoConnectGetApNum); memset(info, 0, sizeof(wifi_auto_connect_info_t) * u8APPAutoConnectGetApNum); for (i = 0; i < u8APPAutoConnectGetApNum; i++) { // TODO: get auto connected ap info Opl_Wifi_AutoConnectApInfo_Get(i, info + i); } /* build blewifi ap list */ for (i = 0; i < u16apCount; ++i) { memcpy(pstWifiAPList[i].ssid, pstAPList[i].ssid, sizeof(pstAPList[i].ssid)); memcpy(pstWifiAPList[i].bssid, pstAPList[i].bssid, WIFI_MAC_ADDRESS_LENGTH); pstWifiAPList[i].rssi = pstAPList[i].rssi; pstWifiAPList[i].auth_mode = pstAPList[i].auth_mode; pstWifiAPList[i].ssid_length = strlen((const char *)pstAPList[i].ssid); pstWifiAPList[i].connected = 0; #if (1 == FLITER_STRONG_AP_EN) pstWifiAPList[i].u8IgnoreReport = false; #endif for (j = 0; j < u8APPAutoConnectGetApNum; j++) { if ((info+j)->ap_channel) { if(!memcmp(pstWifiAPList[i].ssid, (info+j)->ssid, sizeof((info+j)->ssid)) && !memcmp(pstWifiAPList[i].bssid, (info+j)->bssid, sizeof((info+j)->bssid))) { pstWifiAPList[i].connected = 1; break; } } } } /* Send Data to BLE */ /* Send AP inforamtion individually */ for (i = 0; i < u16apCount; ++i) { #if (1 == FLITER_STRONG_AP_EN) if(true == pstWifiAPList[i].u8IgnoreReport) { continue; } #endif if(pstWifiAPList[i].ssid_length != 0) { _OPL_DataHandler_SendSignalScanReport(1, &pstWifiAPList[i]); osDelay(100); } } if (pstAPList) free(pstAPList); if (pstWifiAPList) free(pstWifiAPList); if (info) free(info); return ubAppErr; } _OPL_DataHandler_SendSignalScanReport will organize the AP list static void _OPL_DataHandler_SendSignalScanReport(uint16_t apCount, T_WmScanInfo *ap_list) { uint8_t *data; int data_len; uint8_t *pos; int malloc_size = sizeof(T_WmScanInfo) * apCount; pos = data = malloc(malloc_size); if (data == NULL) { OPL_LOG_ERRO(OPL, \"malloc fail\"); return; } for (int i = 0; i < apCount; ++i) { uint8_t len = ap_list[i].ssid_length; data_len = (pos - data); *pos++ = len; memcpy(pos, ap_list[i].ssid, len); pos += len; memcpy(pos, ap_list[i].bssid,6); pos += 6; *pos++ = ap_list[i].auth_mode; *pos++ = ap_list[i].rssi; #ifdef CK_DATA_USE_CONNECTED *pos++ = ap_list[i].connected; #else *pos++ = 0; #endif } data_len = (pos - data); /* create scan report data packet */ OPL_DataSendEncap(OPL_DATA_RSP_SCAN_REPORT, data, data_len); free(data); } OPL_DataSendEncap is responsible for packing data in accordance with BLE packet format. void OPL_DataSendEncap(uint16_t u16Type, uint8_t *pu8Data, uint32_t u32TotalDataLen) { T_OplDataHdrTag *tHdrTag = NULL; int remain_len = u32TotalDataLen; /* 1.fragment data packet to fit MTU size */ /* 2.Pack blewifi header */ tHdrTag = malloc(sizeof(T_OplDataHdrTag) + remain_len); if (tHdrTag == NULL) { OPL_LOG_ERRO(OPL, \"malloc fail\"); return; } tHdrTag->u16EventId = u16Type; tHdrTag->u16DataLen = remain_len; if (tHdrTag->u16DataLen) memcpy(tHdrTag->au8Data, pu8Data, tHdrTag->u16DataLen); /* 3.send app data to BLE stack */ Opl_Ble_Send_Message(OPL_SVC_EVT_SEND_DATA, (uint8_t *)tHdrTag, (tHdrTag->u16DataLen + sizeof(T_OplDataHdrTag)), 0); free(tHdrTag); } Opl_Ble_Send_Message is responsible for sending scan done result (e.g. AP list) to phone via BLE Manager.","title":"WI-FI Provision Via BLE"},{"location":"application-guide/wifi_provision_via_ble.html#wi-fi-provision-via-ble","text":"The advantage of dual-core chip (OPL series), QuickDev-Framework provide a process to provision Wi-Fi credentials of the Home AP via the Bluetooth low energy (BLE). This setion can help the developer to quickly understand and implement the protocol into the application. This block diagram introduces the architecture of the provision Wi-Fi credentials via BLE. The phone (BLE central) will transmitting the required message to the device. When the device received the message, it will process the Wi-Fi connection base on the given information. Opulinks also provide a reference code-base for Phone APP, the front-end developer can use the needed code-base to enhance on their project/product. Android APP : IOS APP : WeChat mini APP :","title":"WI-FI provision via BLE"},{"location":"application-guide/wifi_provision_via_ble.html#provision-process","text":"QuickDev-Framework had provided the Wi-Fi provision via BLE protocol, for a quick look to the example which can demonstrate the Wi-Fi provision via BLE protocol, please check on QD_APP section. In below diagram, it present a simplify steps that how's the provision done. When the phone (BLE central) wants to provision the Wi-Fi credential and connect to AP, the phone (BLE central) will send the command and required message to the device, e.g. Wi-Fi scan request or Wi-Fi connect request. And the device is responsible to receive and parsing the required message, then progress the Network manager to processing according to different events. While Network manager had done with indicate or unsolicited callback returns, then the device will transit the corresponding response or result to the phone (BLE central) for notify the status. The focusing of provision process is to create a BLE data command list to letting the phone (BLE central) and the device can recognize the data and handling in such.","title":"Provision Process"},{"location":"application-guide/wifi_provision_via_ble.html#opl-service","text":"OPL service is one of the profile service collection in BLE which designed by Opulinks that including the Wi-Fi provision command & handler needed. Info To understand the BLE manager and BLE service can refer to BluetoothLE The OPL service UUID defined in quick_dev/app_ref/ble_data_prot/opl_data/opl_svc.h Service/Characteristic UUID OPL service 0xAAAA DATA IN character 0xBBB0 DATA OUT character 0xBBB1","title":"OPL Service"},{"location":"application-guide/wifi_provision_via_ble.html#initialize","text":"To using this service on your application, please follow in below items.","title":"Initialize"},{"location":"application-guide/wifi_provision_via_ble.html#initialize-the-opl-service-in-your-application","text":"Add OPL_Svc_Init() in app_main.c void APP_BleInit(void) { // assign unsolicited callback function Opl_Ble_Uslctd_CB_Reg(&APP_BleUnsolicitedCallback); // register service GAP_Svc_Init(); GATT_Svc_Init(); // register opl service OPL_Svc_Init(); // <- initialize OPL service // initialize the ble manager (auto-adv) Opl_Ble_Init_Req(true); // user implement }","title":"Initialize the OPL service in your application"},{"location":"application-guide/wifi_provision_via_ble.html#generate-a-data-passthrough","text":"When the data received, the OPL_SVC_DATA_IN characteristic contents in OPL service will execute a context switch to passing the received data from BLE manager to host application, so we need to create a catcher on application side, and let it process the data parsing and progress. Add the APP_EVT_BLE_DATA_IND event and handler in app_main.c . static T_AppEvtHandlerTbl g_tAppEvtHandlerTbl[] = { ... {APP_EVT_BLE_DATA_IND, APP_EvtHandler_BleDataInd}, ... {0xFFFFFFFF, NULL}, }; Then add OPL_DataRecvHandler() to let the handler do parsing and progress. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); } At final step, we must enable the protocol which defined in `qd_module.h\" //========================================================== // <h> OPL Data protocol //========================================================== // <e> OPL_DATA_ENABLED - Opulinks BLE WI-FI data protocol //========================================================== #ifndef OPL_DATA_ENABLED #define OPL_DATA_ENABLED (1) #endif And that's the wrap, the Wi-Fi provision via BLE function has been activated in your application. It's recommend to using our standard phone APP by searching \"Opulinks Wireless Utilities\" at APP store to try with.","title":"Generate a data passthrough"},{"location":"application-guide/wifi_provision_via_ble.html#how-to","text":"","title":"How to..."},{"location":"application-guide/wifi_provision_via_ble.html#how-to-create-an-user-defined-service-eg-quick_devapp_refble_data_protopl_svcc-in-ble-manager","text":"Please refer to BluetoothLE","title":"How to create an user defined service (e.g. quick_dev\\app_ref\\ble_data_prot\\opl_svc.c) in BLE Manager"},{"location":"application-guide/wifi_provision_via_ble.html#how-to-receive-ble-data-in-and-then-export-to-ble-application-in-application","text":"Create a gatt dispatch handler (e.g. OPL_Svc_GattDispatchHandler() ) in user defined service static T_OplErr OPL_Svc_GattDispatchHandler(MESSAGEID tId, MESSAGE tMsg) { switch(tId) { case LE_GATT_MSG_ACCESS_READ_IND: { OPL_Svc_GattDispatchReadHandler((LE_GATT_MSG_ACCESS_READ_IND_T *)tMsg); break; } case LE_GATT_MSG_ACCESS_WRITE_IND: { OPL_Svc_GattDispatchWriteHandler((LE_GATT_MSG_ACCESS_WRITE_IND_T *)tMsg); break; } case LE_GATT_MSG_NOTIFY_CFM: { Opl_Ble_Send_Message(OPL_SVC_EVT_SEND_TO_PEER_CFM, NULL, 0, 0); break; } default: { return OPL_ERR_CASE_INVALID; } } return OPL_OK; } This example is receiving LE_GATT_MSG_ACCESS_WRITE_IND event to handle BLE data via OPL_Svc_GattDispatchWriteHandler() tatic void OPL_Svc_GattDispatchWriteHandler(LE_GATT_MSG_ACCESS_WRITE_IND_T *ind) { // process the write access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tOplSvcHandle.ptSvcDef->startHdl; switch(u16AttrId) { case OPL_SVC_IDX_DATA_IN_VAL: { APP_SendMessage(APP_EVT_BLE_DATA_IND, ind->pVal, ind->len); break; } case OPL_SVC_IDX_DATA_OUT_CFG: { uint16_t u16Enable = *((uint16_t *)ind->pVal); if ((ind->len == 2) && (u16Enable <= 1)) { LeGattChangeAttrVal(g_tOplSvcHandle.ptSvcDef, OPL_SVC_IDX_DATA_OUT_CFG, sizeof(u16Enable), &u16Enable); } else { u8AttErr = LE_ATT_ERR_INVALID_ATTR_VALUE_LEN; } break; } default: { u8AttErr = LE_ATT_ERR_WRITE_NOT_PERMITTED; break; } } If receiving OPL_SVC_IDX_DATA_IN_VAL , OPL_Svc_GattDispatchWriteHandler() could send BLE data to application via APP_SendMessage() In application, developer could create a function (e.g. APP_EvtHandler_BleDataInd() ) to send BLE data to BLE Application. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); }","title":"How to receive BLE data in and then export to BLE Application in application"},{"location":"application-guide/wifi_provision_via_ble.html#how-to-handle-wi-fi-provision-message-via-ble-in-ble-application","text":"BLE Application is responsible for parsing the messages from BLE, and then processing these events by category. Wi-Fi provision messages include Wi-Fi scan, Wi-Fi connect, Wi-Fi disconnect, Wi-Fi reconnect, read device Wi-Fi information, write Wi-Fi device information, get device Wi-Fi status and reset Wi-Fi. It is a BLE Application event handler table g_tOplDataEventHandlerTbl to handle these events. static T_OplDataEventTable g_tOplDataEventHandlerTbl[] = { {OPL_DATA_REQ_SCAN, OPL_DataProtocol_Scan}, {OPL_DATA_REQ_CONNECT, OPL_DataProtocol_Connect}, {OPL_DATA_REQ_DISCONNECT, OPL_DataProtocol_Disconnect}, {OPL_DATA_REQ_RECONNECT, OPL_DataProtocol_Reconnect}, {OPL_DATA_REQ_READ_DEVICE_INFO, OPL_DataProtocol_ReadDeviceInfo}, {OPL_DATA_REQ_WRITE_DEVICE_INFO, OPL_DataProtocol_WriteDeviceInfo}, {OPL_DATA_REQ_WIFI_STATUS, OPL_DataProtocol_WifiStatus}, {OPL_DATA_REQ_RESET, OPL_DataProtocol_Reset}, For example, if receiving OPL_DATA_REQ_SCAN , OPL_DataProtocol_Scan handler will send Wi-Fi scan message to Network Manager to execute Wi-Fi scan. static void OPL_DataProtocol_Scan(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_SCAN\"); // reset connection config table memset(&g_tOplDataConnCfg, 0, sizeof(T_OplDataConnCfg)); g_tOplDataConnCfg.u8ConnectType = OPL_DATA_CONN_TYPE_BSSID; // trigger scan request APP_NmWifiScanReq(OPL_DataHandler_WifiScanDoneIndCb); }","title":"How to handle Wi-Fi provision message via BLE in BLE Application"},{"location":"application-guide/wifi_provision_via_ble.html#how-to-respnose-wi-fi-process-result-to-phone","text":"BLE Application send Wi-Fi provision message to Network Manager, and then Network Manager will create a callback function to handle indicate callback. For example, if Wi-Fi scan done, the Wi-FI scan done callback OPL_DataHandler_WifiScanDoneIndCb will follow up on scan done. void OPL_DataHandler_WifiScanDoneIndCb(T_OplErr tEvtRst) { OPL_LOG_DEBG(OPL, \"Wifi scan done ind %d\", tEvtRst); if(OPL_DATA_CONN_TYPE_BSSID == g_tOplDataConnCfg.u8ConnectType) { // CK_DATA_REQ_SCAN cmd, just do report scan list _OPL_DataHandler_SendScanReport(); OPL_DataSendResponse(OPL_DATA_RSP_SCAN_END, 0); } } _OPL_DataHandler_SendScanReport will obtain the information of APs via Wi-Fi Manager in the environment, and sort out the AP list. static int _OPL_DataHandler_SendScanReport(void) { wifi_scan_info_t *pstAPList = NULL; wifi_auto_connect_info_t *info = NULL; T_WmScanInfo *pstWifiAPList = NULL; uint8_t u8APPAutoConnectGetApNum = 0; // uint8_t u8IsUpdate = false; uint16_t u16apCount = 0; int32_t i = 0, j = 0; // TODO: get ap number Opl_Wifi_ApNum_Get(&u16apCount); OPL_LOG_INFO(OPL, \"AP num = %d\", u16apCount); pstAPList = (wifi_scan_info_t *)malloc(sizeof(wifi_scan_info_t) * u16apCount); // TODO: get ap record Opl_Wifi_ApRecord_Get(&u16apCount, pstAPList); pstWifiAPList = (T_WmScanInfo *)malloc(sizeof(T_WmScanInfo) * u16apCount); memset(pstWifiAPList , 0 , sizeof(T_WmScanInfo) * u16apCount); // TODO: get auto connect ap number Opl_Wifi_AutoConnectApNum_Get(&u8APPAutoConnectGetApNum); if (u8APPAutoConnectGetApNum) { info = (wifi_auto_connect_info_t *)malloc(sizeof(wifi_auto_connect_info_t) * u8APPAutoConnectGetApNum); memset(info, 0, sizeof(wifi_auto_connect_info_t) * u8APPAutoConnectGetApNum); for (i = 0; i < u8APPAutoConnectGetApNum; i++) { // TODO: get auto connected ap info Opl_Wifi_AutoConnectApInfo_Get(i, info + i); } /* build blewifi ap list */ for (i = 0; i < u16apCount; ++i) { memcpy(pstWifiAPList[i].ssid, pstAPList[i].ssid, sizeof(pstAPList[i].ssid)); memcpy(pstWifiAPList[i].bssid, pstAPList[i].bssid, WIFI_MAC_ADDRESS_LENGTH); pstWifiAPList[i].rssi = pstAPList[i].rssi; pstWifiAPList[i].auth_mode = pstAPList[i].auth_mode; pstWifiAPList[i].ssid_length = strlen((const char *)pstAPList[i].ssid); pstWifiAPList[i].connected = 0; #if (1 == FLITER_STRONG_AP_EN) pstWifiAPList[i].u8IgnoreReport = false; #endif for (j = 0; j < u8APPAutoConnectGetApNum; j++) { if ((info+j)->ap_channel) { if(!memcmp(pstWifiAPList[i].ssid, (info+j)->ssid, sizeof((info+j)->ssid)) && !memcmp(pstWifiAPList[i].bssid, (info+j)->bssid, sizeof((info+j)->bssid))) { pstWifiAPList[i].connected = 1; break; } } } } /* Send Data to BLE */ /* Send AP inforamtion individually */ for (i = 0; i < u16apCount; ++i) { #if (1 == FLITER_STRONG_AP_EN) if(true == pstWifiAPList[i].u8IgnoreReport) { continue; } #endif if(pstWifiAPList[i].ssid_length != 0) { _OPL_DataHandler_SendSignalScanReport(1, &pstWifiAPList[i]); osDelay(100); } } if (pstAPList) free(pstAPList); if (pstWifiAPList) free(pstWifiAPList); if (info) free(info); return ubAppErr; } _OPL_DataHandler_SendSignalScanReport will organize the AP list static void _OPL_DataHandler_SendSignalScanReport(uint16_t apCount, T_WmScanInfo *ap_list) { uint8_t *data; int data_len; uint8_t *pos; int malloc_size = sizeof(T_WmScanInfo) * apCount; pos = data = malloc(malloc_size); if (data == NULL) { OPL_LOG_ERRO(OPL, \"malloc fail\"); return; } for (int i = 0; i < apCount; ++i) { uint8_t len = ap_list[i].ssid_length; data_len = (pos - data); *pos++ = len; memcpy(pos, ap_list[i].ssid, len); pos += len; memcpy(pos, ap_list[i].bssid,6); pos += 6; *pos++ = ap_list[i].auth_mode; *pos++ = ap_list[i].rssi; #ifdef CK_DATA_USE_CONNECTED *pos++ = ap_list[i].connected; #else *pos++ = 0; #endif } data_len = (pos - data); /* create scan report data packet */ OPL_DataSendEncap(OPL_DATA_RSP_SCAN_REPORT, data, data_len); free(data); } OPL_DataSendEncap is responsible for packing data in accordance with BLE packet format. void OPL_DataSendEncap(uint16_t u16Type, uint8_t *pu8Data, uint32_t u32TotalDataLen) { T_OplDataHdrTag *tHdrTag = NULL; int remain_len = u32TotalDataLen; /* 1.fragment data packet to fit MTU size */ /* 2.Pack blewifi header */ tHdrTag = malloc(sizeof(T_OplDataHdrTag) + remain_len); if (tHdrTag == NULL) { OPL_LOG_ERRO(OPL, \"malloc fail\"); return; } tHdrTag->u16EventId = u16Type; tHdrTag->u16DataLen = remain_len; if (tHdrTag->u16DataLen) memcpy(tHdrTag->au8Data, pu8Data, tHdrTag->u16DataLen); /* 3.send app data to BLE stack */ Opl_Ble_Send_Message(OPL_SVC_EVT_SEND_DATA, (uint8_t *)tHdrTag, (tHdrTag->u16DataLen + sizeof(T_OplDataHdrTag)), 0); free(tHdrTag); } Opl_Ble_Send_Message is responsible for sending scan done result (e.g. AP list) to phone via BLE Manager.","title":"How to respnose Wi-Fi process result to phone"},{"location":"examples/ble_example.html","text":"BLE examples BLE examples are intended to demonstrate the BLE functionality, and to provide code that you can copy and adapt into your own projects BLE battery service This example creates BLE battery service with the Battery Level characteristic to monitor battery levels. This example application is in \\examples\\ble\\ble_svc_battery . The BLE battery service is in \\quick_dev\\app_ref\\ble_services\\bas_svc.c . During initialization, it starts system timers and adds battery services and battery level characteristic. After the timer timeout, the device will notify the client the battery level characteristics. BLE data input/output service This example creates BLE data input/output service send or receive data via BLE. The example application is in \\examples\\ble\\ble_svc_data_io . The BLE User Data Service is in \\quick_dev\\app_ref\\ble_services\\ud_svc.c . When the user sends data, the data will be sent to the Le task first. Then Le task will pass the data into the GattDispatchHandler in User define Service. According data's access permission that include read, write or notify, developer could create different handler to handle. This example use write handler GattWriteHandler to handle write access data from phone (APP). GattWriteHandler will be responsible for passing the data to the application, and the application will return the respnose to the phone (APP) via DataoutNotify.","title":"BLE"},{"location":"examples/ble_example.html#ble-examples","text":"BLE examples are intended to demonstrate the BLE functionality, and to provide code that you can copy and adapt into your own projects","title":"BLE examples"},{"location":"examples/ble_example.html#ble-battery-service","text":"This example creates BLE battery service with the Battery Level characteristic to monitor battery levels. This example application is in \\examples\\ble\\ble_svc_battery . The BLE battery service is in \\quick_dev\\app_ref\\ble_services\\bas_svc.c . During initialization, it starts system timers and adds battery services and battery level characteristic. After the timer timeout, the device will notify the client the battery level characteristics.","title":"BLE battery service"},{"location":"examples/ble_example.html#ble-data-inputoutput-service","text":"This example creates BLE data input/output service send or receive data via BLE. The example application is in \\examples\\ble\\ble_svc_data_io . The BLE User Data Service is in \\quick_dev\\app_ref\\ble_services\\ud_svc.c . When the user sends data, the data will be sent to the Le task first. Then Le task will pass the data into the GattDispatchHandler in User define Service. According data's access permission that include read, write or notify, developer could create different handler to handle. This example use write handler GattWriteHandler to handle write access data from phone (APP). GattWriteHandler will be responsible for passing the data to the application, and the application will return the respnose to the phone (APP) via DataoutNotify.","title":"BLE data input/output service"},{"location":"examples/cloud_example.html","text":"Cloud examples Cloud examples are intented to demonstrate the connection and data post / receive activity on different cloud protocol, and present a simple cloud usage in each application. The developer can reference the ported program and extent or modify in needed. Most of the cloud library provided by QuickDev-Framework are ported base on Cloud Template archietecture. TCP demo The TCP cloud is a basic communication protocol which can easily pass the data between host and client, and the TCP demo example demonstrate a simple used of TCP cloud library to communicate with server. TCP demo example located at /examples/cloud/tcp_demo . The following message sequence chart present the simplified application scenario of this example. In the beginning of the sequence, the device will connect to the AP auto-matically if the device had a connected record, check on Wi-Fi section for more information. If the device is first used and/or no record exists, user can activate Wi-Fi provision via BLE procedure to select and connect to dediacted AP. When the Wi-Fi is up, the scenairo will directly trigger the cloud establish activity to connect to the TCP server base on the definition which configured to server IP address. After the connection linked, the application scenario then start the periodic data post to transit data base on interval time. During the connection, TCP cloud library will also handle the keep-alive and passing the received data to application. Note TCP demo example also provide AT commands in app_at_cmd.c to configure the connection information during testing. Please note that setting the power mode to Performance is required. Setup TCP Socket Test The TCP Socket Test is a free tool which help user to create the TCP / UDP client or server. The Java environment is necessary for the client/server setup. TCP Socket Test: http://sockettest.sourceforge.net/ In the following try out, we will apply this tool to create the TCP server that the device can connect to and transmit the data. Testing Step.1 Open TCP local server Open the TCP Socket Test tool, and select to Server tag as following diagram, and directly click Start Listening button to start the server. Step.2 Configure IP and Port Due to the device will connect to TCP Socket Test server in same local network that we just started at Step.1 , in the program we will modify the default IP address and port number sets to TCP server IP address and port number, the code located in cloud_config.h . Info TCP Socket Test server using 0.0.0.0 IP address, for the device, the linked IP address will be your PC's IP address. Change the default IP address and port number in cloud_config.h file located in /quick_dev/app_ref/cloud/tcp_cloud . // TCP server setup #define TCP_HOST_IP (\"192.168.0.0\") // the TCP server IP address #define TCP_HOST_IP_SIZE (15) #define TCP_HOST_PORT (21) // the TCP server port number Step.3 Compile and Download Click Build or Rebuild button to compiler project. Output file <Project name>.bin located at <Project root>/Output/Object . You can follow Step5 and Step6 section in Get started to compile and download the project. Step.4 Connect to AP As the TCP demo sequence chart section mentioned, the device will connect to the AP auto-matically if the device had a connected record. If not, the device will enable the provision process after boot up, and let user to select and connect AP. Refer to Wi-Fi provision via BLE section in QD APP try out. Note If not applying public TCP server, we recommand that the device and TCP server connect to the same AP during privision. When Wi-Fi status is up, the application will directly trigger the TCP connection. After the successful cloud connection, the device will shows the log like following screenshot. Step.5 Post data to server After the cloud connected, the application will start the periodic data post in every 20 sec, the interval number configured in qd_config.h . // <o> TCP_DEMO_PERI_POST_EN - enable periodic post data #ifndef TCP_DEMO_PERI_POST_EN #define TCP_DEMO_PERI_POST_EN (1) #endif // <o> TCP_DEMO_PERI_POST_INTERVAL - periodic post data interval time (ms) #ifndef TCP_DEMO_PERI_POST_INTERVAL #define TCP_DEMO_PERI_POST_INTERVAL (20000) #endif While expired, the application will post HelloTCP message to server. The following message will display in TCP server console if received. Screenshot of Device : Screenshot of TCP server : Step.6 Receive data from server In this step we will send some message from TCP server to the device, we can insert some message like HelloDevice in Message textbox, and press Send button to transit the message to the device. Screenshot of TCP server : Screenshot of Device : Step.7 Check keep-alive message After cloud connected, the keep-alive scenario will be started base on the keep-alive interval setting. Once the keep-alive timer expired, the device will send ping message to TCP server as following diagram. Screenshot of Device : Screenshot of TCP server : MQTT demo The MQTT is a publish/subscribe messaging protocol that works on top of the TCP/IP protocol, in MQTT demo example demonstrate a simple used of MQTT cloud library to communicate with server. MQTT demo example located at /examples/cloud/mqtt_demo . The following message sequence chart present the simplified application scenario of this example. In the beginning of the sequence, the device will connect to the AP auto-matically if the device had a connected record, check on Wi-Fi section for more information. If the device is first used and/or no record exists, user can activate Wi-Fi provision via BLE procedure to select and connect to dediacted AP. When the Wi-Fi is up, the scenairo will first register an subscribe topic QD_FWK/MQTT_DEMO/SUB_Test/1 and trigger the cloud establish activity to connect to the MQTT broker base on definition which configured to borker URL. After the connection linked, the scenario then will register another subscribe topic QD_FWK/MQTT_DEMO/SUB_Test/2 and start the periodic data posting to the QD_FWK/MQTT_DEMO/PUB_Test/1 topic base on interval time. During the connection, MQTT cloud library will also handle the keep-alive. Setup MQTT-X The MQTT-X is a cross-platform MQTT desktop client tool from emqx.io , in the following try out we will use this tool as another client charater to check / send message on subscribed / publicted topics. MQTT-X: https://mqttx.app Testing In this try out, we will using the public server mqtts://broker.emqx.io as a test MQTT broker, check in following link for more detail of emqx borker. Public EMQX MQTT broker: https://www.emqx.com/en/mqtt/public-mqtt5-broker Step.1 Start a client on MQTT-X Open the MQTT-X tool and select + to start a new client. Then insert the setup like following lists. Name - The client name Client ID - The client unique identify Host - The MQTT broker URL ( broker.emqx.io ) Port - the port number ( 8883 ) SSL/TLS - Enable / Disable the SSL/TLS connection ( enable ) Certificate - Select CA signed server / Self signed ( CA signed server ) Then press Connect button to start the connection with broker. If the connection successful, the MQTT-X will jump to the control panel like following screenshot. According to MQTT demo sequence chart mention, the device will send the data to QD_FWK/MQTT_DEMO/PUB_Test/1 topic in periodic, so in other side of MQTT-X tool we need to subscribe the QD_FWK/MQTT_DEMO/PUB_Test/1 topic to listen and receive the data that posted from the device. Press New Subscription to create the QD_FWK/MQTT_DEMO/PUB_Test/1 topic like following diagram. Step.2 Configure the broker URL Due to we're using the broker.emqx.io public MQTT broker as our testing broker, in program we need to modify the default URL and port number sets to the following code, the code located in cloud_config.h . // MQTT server setup #define MQTT_HOST_URL \"broker.emqx.io\" #define MQTT_HOST_PORT (8883) Step.3 Compile and Download Click Build or Rebuild button to compiler project. Output file <Project name>.bin located at <Project root>/Output/Object . You can follow Step5 and Step6 section in Get started to compile and download the project. Step.4 Connect to AP As mention in MQTT demo sequence char section, the device will connect to the AP auto-matically if the device had a connected record. If not, the debug will enable the provision process when boot up, and let user to select and connect AP. Please refer to Wi-Fi provision via BLE section in QD APP try out. When Wi-Fi status is up, the application will directly trigger the MQTT connection. After the successful cloud connection, the device will shows the log like following screenshot. Step.5 Post data to server After the cloud connected, the application will start the periodic data post in every 20 sec, the interval number configured in qd_config.h . // <o> MQTT_DEMO_PERI_POST_EN - enable periodic post data #ifndef MQTT_DEMO_PERI_POST_EN #define MQTT_DEMO_PERI_POST_EN (1) #endif // <o> MQTT_DEMO_PERI_POST_INTERVAL - periodic post data interval time (ms) #ifndef MQTT_DEMO_PERI_POST_INTERVAL #define MQTT_DEMO_PERI_POST_INTERVAL (20000) #endif While expired, the application will post HelloMQTT message to QD_FWK/MQTT_DEMO/PUB_Test/1 topic. The following message will display in TCP server console if received. Step.6 Receive data from server In this step we will send some message from MQTT-X client to the device, we can insert some message like HelloDevice in send console and assgin the public topic /MQTT/DEMO/OPL/SUB1 or /MQTT/DEMO/OPL/SUB2 , then press send icon to transit the message to the device. Step.7 Check keep-alive message After cloud connected, the keep-alive scenario will be started base on the keep-alive interval setting. Once the keep-alive timer expired, the MQTT library will handle the keep-alive with MQTT broker, the message of keep-alive processing as following diagram.","title":"Cloud"},{"location":"examples/cloud_example.html#cloud-examples","text":"Cloud examples are intented to demonstrate the connection and data post / receive activity on different cloud protocol, and present a simple cloud usage in each application. The developer can reference the ported program and extent or modify in needed. Most of the cloud library provided by QuickDev-Framework are ported base on Cloud Template archietecture.","title":"Cloud examples"},{"location":"examples/cloud_example.html#tcp-demo","text":"The TCP cloud is a basic communication protocol which can easily pass the data between host and client, and the TCP demo example demonstrate a simple used of TCP cloud library to communicate with server. TCP demo example located at /examples/cloud/tcp_demo . The following message sequence chart present the simplified application scenario of this example. In the beginning of the sequence, the device will connect to the AP auto-matically if the device had a connected record, check on Wi-Fi section for more information. If the device is first used and/or no record exists, user can activate Wi-Fi provision via BLE procedure to select and connect to dediacted AP. When the Wi-Fi is up, the scenairo will directly trigger the cloud establish activity to connect to the TCP server base on the definition which configured to server IP address. After the connection linked, the application scenario then start the periodic data post to transit data base on interval time. During the connection, TCP cloud library will also handle the keep-alive and passing the received data to application. Note TCP demo example also provide AT commands in app_at_cmd.c to configure the connection information during testing. Please note that setting the power mode to Performance is required.","title":"TCP demo"},{"location":"examples/cloud_example.html#setup","text":"","title":"Setup"},{"location":"examples/cloud_example.html#tcp-socket-test","text":"The TCP Socket Test is a free tool which help user to create the TCP / UDP client or server. The Java environment is necessary for the client/server setup. TCP Socket Test: http://sockettest.sourceforge.net/ In the following try out, we will apply this tool to create the TCP server that the device can connect to and transmit the data.","title":"TCP Socket Test"},{"location":"examples/cloud_example.html#testing","text":"","title":"Testing"},{"location":"examples/cloud_example.html#step1-open-tcp-local-server","text":"Open the TCP Socket Test tool, and select to Server tag as following diagram, and directly click Start Listening button to start the server.","title":"Step.1 Open TCP local server"},{"location":"examples/cloud_example.html#step2-configure-ip-and-port","text":"Due to the device will connect to TCP Socket Test server in same local network that we just started at Step.1 , in the program we will modify the default IP address and port number sets to TCP server IP address and port number, the code located in cloud_config.h . Info TCP Socket Test server using 0.0.0.0 IP address, for the device, the linked IP address will be your PC's IP address. Change the default IP address and port number in cloud_config.h file located in /quick_dev/app_ref/cloud/tcp_cloud . // TCP server setup #define TCP_HOST_IP (\"192.168.0.0\") // the TCP server IP address #define TCP_HOST_IP_SIZE (15) #define TCP_HOST_PORT (21) // the TCP server port number","title":"Step.2 Configure IP and Port"},{"location":"examples/cloud_example.html#step3-compile-and-download","text":"Click Build or Rebuild button to compiler project. Output file <Project name>.bin located at <Project root>/Output/Object . You can follow Step5 and Step6 section in Get started to compile and download the project.","title":"Step.3 Compile and Download"},{"location":"examples/cloud_example.html#step4-connect-to-ap","text":"As the TCP demo sequence chart section mentioned, the device will connect to the AP auto-matically if the device had a connected record. If not, the device will enable the provision process after boot up, and let user to select and connect AP. Refer to Wi-Fi provision via BLE section in QD APP try out. Note If not applying public TCP server, we recommand that the device and TCP server connect to the same AP during privision. When Wi-Fi status is up, the application will directly trigger the TCP connection. After the successful cloud connection, the device will shows the log like following screenshot.","title":"Step.4 Connect to AP"},{"location":"examples/cloud_example.html#step5-post-data-to-server","text":"After the cloud connected, the application will start the periodic data post in every 20 sec, the interval number configured in qd_config.h . // <o> TCP_DEMO_PERI_POST_EN - enable periodic post data #ifndef TCP_DEMO_PERI_POST_EN #define TCP_DEMO_PERI_POST_EN (1) #endif // <o> TCP_DEMO_PERI_POST_INTERVAL - periodic post data interval time (ms) #ifndef TCP_DEMO_PERI_POST_INTERVAL #define TCP_DEMO_PERI_POST_INTERVAL (20000) #endif While expired, the application will post HelloTCP message to server. The following message will display in TCP server console if received. Screenshot of Device : Screenshot of TCP server :","title":"Step.5 Post data to server"},{"location":"examples/cloud_example.html#step6-receive-data-from-server","text":"In this step we will send some message from TCP server to the device, we can insert some message like HelloDevice in Message textbox, and press Send button to transit the message to the device. Screenshot of TCP server : Screenshot of Device :","title":"Step.6 Receive data from server"},{"location":"examples/cloud_example.html#step7-check-keep-alive-message","text":"After cloud connected, the keep-alive scenario will be started base on the keep-alive interval setting. Once the keep-alive timer expired, the device will send ping message to TCP server as following diagram. Screenshot of Device : Screenshot of TCP server :","title":"Step.7 Check keep-alive message"},{"location":"examples/cloud_example.html#mqtt-demo","text":"The MQTT is a publish/subscribe messaging protocol that works on top of the TCP/IP protocol, in MQTT demo example demonstrate a simple used of MQTT cloud library to communicate with server. MQTT demo example located at /examples/cloud/mqtt_demo . The following message sequence chart present the simplified application scenario of this example. In the beginning of the sequence, the device will connect to the AP auto-matically if the device had a connected record, check on Wi-Fi section for more information. If the device is first used and/or no record exists, user can activate Wi-Fi provision via BLE procedure to select and connect to dediacted AP. When the Wi-Fi is up, the scenairo will first register an subscribe topic QD_FWK/MQTT_DEMO/SUB_Test/1 and trigger the cloud establish activity to connect to the MQTT broker base on definition which configured to borker URL. After the connection linked, the scenario then will register another subscribe topic QD_FWK/MQTT_DEMO/SUB_Test/2 and start the periodic data posting to the QD_FWK/MQTT_DEMO/PUB_Test/1 topic base on interval time. During the connection, MQTT cloud library will also handle the keep-alive.","title":"MQTT demo"},{"location":"examples/cloud_example.html#setup_1","text":"","title":"Setup"},{"location":"examples/cloud_example.html#mqtt-x","text":"The MQTT-X is a cross-platform MQTT desktop client tool from emqx.io , in the following try out we will use this tool as another client charater to check / send message on subscribed / publicted topics. MQTT-X: https://mqttx.app","title":"MQTT-X"},{"location":"examples/cloud_example.html#testing_1","text":"In this try out, we will using the public server mqtts://broker.emqx.io as a test MQTT broker, check in following link for more detail of emqx borker. Public EMQX MQTT broker: https://www.emqx.com/en/mqtt/public-mqtt5-broker","title":"Testing"},{"location":"examples/cloud_example.html#step1-start-a-client-on-mqtt-x","text":"Open the MQTT-X tool and select + to start a new client. Then insert the setup like following lists. Name - The client name Client ID - The client unique identify Host - The MQTT broker URL ( broker.emqx.io ) Port - the port number ( 8883 ) SSL/TLS - Enable / Disable the SSL/TLS connection ( enable ) Certificate - Select CA signed server / Self signed ( CA signed server ) Then press Connect button to start the connection with broker. If the connection successful, the MQTT-X will jump to the control panel like following screenshot. According to MQTT demo sequence chart mention, the device will send the data to QD_FWK/MQTT_DEMO/PUB_Test/1 topic in periodic, so in other side of MQTT-X tool we need to subscribe the QD_FWK/MQTT_DEMO/PUB_Test/1 topic to listen and receive the data that posted from the device. Press New Subscription to create the QD_FWK/MQTT_DEMO/PUB_Test/1 topic like following diagram.","title":"Step.1 Start a client on MQTT-X"},{"location":"examples/cloud_example.html#step2-configure-the-broker-url","text":"Due to we're using the broker.emqx.io public MQTT broker as our testing broker, in program we need to modify the default URL and port number sets to the following code, the code located in cloud_config.h . // MQTT server setup #define MQTT_HOST_URL \"broker.emqx.io\" #define MQTT_HOST_PORT (8883)","title":"Step.2 Configure the broker URL"},{"location":"examples/cloud_example.html#step3-compile-and-download_1","text":"Click Build or Rebuild button to compiler project. Output file <Project name>.bin located at <Project root>/Output/Object . You can follow Step5 and Step6 section in Get started to compile and download the project.","title":"Step.3 Compile and Download"},{"location":"examples/cloud_example.html#step4-connect-to-ap_1","text":"As mention in MQTT demo sequence char section, the device will connect to the AP auto-matically if the device had a connected record. If not, the debug will enable the provision process when boot up, and let user to select and connect AP. Please refer to Wi-Fi provision via BLE section in QD APP try out. When Wi-Fi status is up, the application will directly trigger the MQTT connection. After the successful cloud connection, the device will shows the log like following screenshot.","title":"Step.4 Connect to AP"},{"location":"examples/cloud_example.html#step5-post-data-to-server_1","text":"After the cloud connected, the application will start the periodic data post in every 20 sec, the interval number configured in qd_config.h . // <o> MQTT_DEMO_PERI_POST_EN - enable periodic post data #ifndef MQTT_DEMO_PERI_POST_EN #define MQTT_DEMO_PERI_POST_EN (1) #endif // <o> MQTT_DEMO_PERI_POST_INTERVAL - periodic post data interval time (ms) #ifndef MQTT_DEMO_PERI_POST_INTERVAL #define MQTT_DEMO_PERI_POST_INTERVAL (20000) #endif While expired, the application will post HelloMQTT message to QD_FWK/MQTT_DEMO/PUB_Test/1 topic. The following message will display in TCP server console if received.","title":"Step.5 Post data to server"},{"location":"examples/cloud_example.html#step6-receive-data-from-server_1","text":"In this step we will send some message from MQTT-X client to the device, we can insert some message like HelloDevice in send console and assgin the public topic /MQTT/DEMO/OPL/SUB1 or /MQTT/DEMO/OPL/SUB2 , then press send icon to transit the message to the device.","title":"Step.6 Receive data from server"},{"location":"examples/cloud_example.html#step7-check-keep-alive-message_1","text":"After cloud connected, the keep-alive scenario will be started base on the keep-alive interval setting. Once the keep-alive timer expired, the MQTT library will handle the keep-alive with MQTT broker, the message of keep-alive processing as following diagram.","title":"Step.7 Check keep-alive message"},{"location":"examples/host_mode_example.html","text":"Host mode example In this host_mode example, the Opulinks device plays as a slave device controlled by another host MCU. The host MCU will send AT command through UART to request Opulinks device to perform WiFi provision, cloud connection, cloud data sending and receiving. The example application located at \u201cexamples\\host_mode\\at_master\u201d(to simulate host MCU) and \u201cexamples\\host_mode\\at_slave\u201d (Opulinks slave device). Architecture WThe Host MCU send request to Opulinks device via UART interface, also a wakeup PIN. Binary Build To setup this demonstration, user must build master and slave binaries separately. There are two kind of cloud server to test, TCP and MQTT. Following screen shot illustrates how to select project with correct server type to build slave binary in MDK-ARM IDE tool. Also do the same to build the correct mater binary. To modify the server IP, find the TCP/MQTT IP setting in \u201cAPP_HostModeDemoProgress\u201d of \u201cexamples\\host_mode\\at_master\\app_main.c\u201d #if defined(HOST_MODE_TCP) strcpy((char *)tHostModeReqCmdFmt.u8aPayload, \"1,192.168.0.10,21\"); #elif defined(HOST_MODE_MQTT) strcpy((char *)tHostModeReqCmdFmt.u8aPayload, \"1,broker.emqx.io,8883\"); #endif Scenarios BLE/WiFi Provision For the first time the host_mode environment has been setup, Master device will send at+provisionstart to Slave device after receiving \u201cReady\u201d. After revceiving provision request in Slave device (see console), user can do WiFi setup on phone App. (Please refer to Start_up example for detail steps) Cloud connection and enter sleep After Wi-Fi connected, Master device will send at+cloudconn to connect cloud. Once connected, Master device will send at+entsleep to ask Slave device to enter power save mode TCP","title":"Host_Mode"},{"location":"examples/host_mode_example.html#host-mode-example","text":"In this host_mode example, the Opulinks device plays as a slave device controlled by another host MCU. The host MCU will send AT command through UART to request Opulinks device to perform WiFi provision, cloud connection, cloud data sending and receiving. The example application located at \u201cexamples\\host_mode\\at_master\u201d(to simulate host MCU) and \u201cexamples\\host_mode\\at_slave\u201d (Opulinks slave device).","title":"Host mode example"},{"location":"examples/host_mode_example.html#architecture","text":"WThe Host MCU send request to Opulinks device via UART interface, also a wakeup PIN.","title":"Architecture"},{"location":"examples/host_mode_example.html#binary-build","text":"To setup this demonstration, user must build master and slave binaries separately. There are two kind of cloud server to test, TCP and MQTT. Following screen shot illustrates how to select project with correct server type to build slave binary in MDK-ARM IDE tool. Also do the same to build the correct mater binary. To modify the server IP, find the TCP/MQTT IP setting in \u201cAPP_HostModeDemoProgress\u201d of \u201cexamples\\host_mode\\at_master\\app_main.c\u201d #if defined(HOST_MODE_TCP) strcpy((char *)tHostModeReqCmdFmt.u8aPayload, \"1,192.168.0.10,21\"); #elif defined(HOST_MODE_MQTT) strcpy((char *)tHostModeReqCmdFmt.u8aPayload, \"1,broker.emqx.io,8883\"); #endif","title":"Binary Build"},{"location":"examples/host_mode_example.html#scenarios","text":"","title":"Scenarios"},{"location":"examples/host_mode_example.html#blewifi-provision","text":"For the first time the host_mode environment has been setup, Master device will send at+provisionstart to Slave device after receiving \u201cReady\u201d. After revceiving provision request in Slave device (see console), user can do WiFi setup on phone App. (Please refer to Start_up example for detail steps) Cloud connection and enter sleep After Wi-Fi connected, Master device will send at+cloudconn to connect cloud. Once connected, Master device will send at+entsleep to ask Slave device to enter power save mode","title":"BLE/WiFi Provision"},{"location":"examples/host_mode_example.html#tcp","text":"","title":"TCP"},{"location":"examples/ota_example.html","text":"OTA examples OTA (Over-The-Air) examples are intended to demonstrate the firmware upgrade over the air base on different application layer protocol, and the examples all using AT command to triggering OTA process. To understand the OTA mechanism, please check on OTA section in appplication-guide. HTTP OTA HTTP OTA example provides the OTA demonstration on HTTP protocol, the user can issue the AT command at+ota with URL to trigger the upgrade, and the application will begin to download the firmware from a given URL of HTTP file server, and will reboot the system after it's done. HTTP OTA example located at /example/ota/http_ota Before start this try out, we're recommend to wire the Debug port and UART1 port to your PC at same time, the connection of wire shows at Device Setting . In cause of two connection, the developer must issue the AT command in this example, and also need to check the printed log of OTA status at same time, so wired two UART port can easy to check at immediate. About the mechanism of HTTP OTA, when the user issue AT command to trigger firmware upgrade, the OTA task handler will receive OTA request from application. After receiving request the OTA task handler will connect to http file server and download binary file. It will also trigger OTA manager to write data to flash. After OTA manager finish write data to flash, it will restart the system to finish the upgrade of your firmware. Setup HTTP File Server The HFS is a free application from rejetto.com that can easily to generate the HTTP file server on your PC. In this example we will use this tool to set the upgradable firmware and it will create a given link for AT command we will issue. HTTP File Server: https://www.rejetto.com/hfs/?f=dl The binary file should be added to HTTP file server, and then the user can start OTA, and download the binary file on HTTP file server. Device Setting This diagram shows how to wire two UART serial port at the same time. GPIO Function Default Mode IO8 UART1 TX AT IO9 UART1 RX AT IO1 DEBUG RX DEBUG IO0 DEBUG TX DEBUG Testing Step1. Build project Click Build and Rebuild button to compiler project. Output file <Project name>.bin located at <Project root>/Output/Object . You can follow Step5 section in Get started to build the project. Step2. Download firmware You can follow Step6 section in Get started to download firmware. Pay attention to OTA tag. Because we need to execute \"HTTP OTA\" process, it is important to set OTA Header Setting : Product ID -> select to the target chip series ID. Chip ID -> select to the target chip ID. Firmware ID -> number of current project version. Checksum -> It will auto-calculated. Note The developer can generate two binary files with different Firmware ID or add some log in program to easily check whether the upgrade is successful or not. Step3. Wi-Fi provision via BLE HTTP OTA example download binary file from HTTP file server so the user must need to set the same AP with HTTP file server. You can follow Wi-Fi provision via BLE section in Start Up examples to set the same AP. Step4. Add binary file to HTTP File Server Add binary file to HTTP File Server. The binary file is located at sdk/Tool/Download/Patch/<project name>.bin . After adding binary file to server, an url will be generated, the user can copy this url (ex:http://190.168.1.52/op1000_ota.bin) and follow next step. Step5. Issue AT command to start OTA. Open two terminals (such as Tera-Term application), one is DBG mode and another is AT mode. DBG mode is to check the message and AT mode is to issue AT command. The user can issue AT command at+OTA=http://<IP address>/<firmware name>.bin to start OTA. If the user success to start OTA, you will get \"OTA start\" on the terminal of DBG console like the below figure. After finishing OTA process, The \"download success\" and \"OTA finish\" messages will show in DBG console of the terminal window. BLE OTA Please refer to Wi-Fi provision via BLE","title":"OTA"},{"location":"examples/ota_example.html#ota-examples","text":"OTA (Over-The-Air) examples are intended to demonstrate the firmware upgrade over the air base on different application layer protocol, and the examples all using AT command to triggering OTA process. To understand the OTA mechanism, please check on OTA section in appplication-guide.","title":"OTA examples"},{"location":"examples/ota_example.html#http-ota","text":"HTTP OTA example provides the OTA demonstration on HTTP protocol, the user can issue the AT command at+ota with URL to trigger the upgrade, and the application will begin to download the firmware from a given URL of HTTP file server, and will reboot the system after it's done. HTTP OTA example located at /example/ota/http_ota Before start this try out, we're recommend to wire the Debug port and UART1 port to your PC at same time, the connection of wire shows at Device Setting . In cause of two connection, the developer must issue the AT command in this example, and also need to check the printed log of OTA status at same time, so wired two UART port can easy to check at immediate. About the mechanism of HTTP OTA, when the user issue AT command to trigger firmware upgrade, the OTA task handler will receive OTA request from application. After receiving request the OTA task handler will connect to http file server and download binary file. It will also trigger OTA manager to write data to flash. After OTA manager finish write data to flash, it will restart the system to finish the upgrade of your firmware.","title":"HTTP OTA"},{"location":"examples/ota_example.html#setup","text":"","title":"Setup"},{"location":"examples/ota_example.html#http-file-server","text":"The HFS is a free application from rejetto.com that can easily to generate the HTTP file server on your PC. In this example we will use this tool to set the upgradable firmware and it will create a given link for AT command we will issue. HTTP File Server: https://www.rejetto.com/hfs/?f=dl The binary file should be added to HTTP file server, and then the user can start OTA, and download the binary file on HTTP file server.","title":"HTTP File Server"},{"location":"examples/ota_example.html#device-setting","text":"This diagram shows how to wire two UART serial port at the same time. GPIO Function Default Mode IO8 UART1 TX AT IO9 UART1 RX AT IO1 DEBUG RX DEBUG IO0 DEBUG TX DEBUG","title":"Device Setting"},{"location":"examples/ota_example.html#testing","text":"","title":"Testing"},{"location":"examples/ota_example.html#step1-build-project","text":"Click Build and Rebuild button to compiler project. Output file <Project name>.bin located at <Project root>/Output/Object . You can follow Step5 section in Get started to build the project.","title":"Step1. Build project"},{"location":"examples/ota_example.html#step2-download-firmware","text":"You can follow Step6 section in Get started to download firmware. Pay attention to OTA tag. Because we need to execute \"HTTP OTA\" process, it is important to set OTA Header Setting : Product ID -> select to the target chip series ID. Chip ID -> select to the target chip ID. Firmware ID -> number of current project version. Checksum -> It will auto-calculated. Note The developer can generate two binary files with different Firmware ID or add some log in program to easily check whether the upgrade is successful or not.","title":"Step2. Download firmware"},{"location":"examples/ota_example.html#step3-wi-fi-provision-via-ble","text":"HTTP OTA example download binary file from HTTP file server so the user must need to set the same AP with HTTP file server. You can follow Wi-Fi provision via BLE section in Start Up examples to set the same AP.","title":"Step3. Wi-Fi provision via BLE"},{"location":"examples/ota_example.html#step4-add-binary-file-to-http-file-server","text":"Add binary file to HTTP File Server. The binary file is located at sdk/Tool/Download/Patch/<project name>.bin . After adding binary file to server, an url will be generated, the user can copy this url (ex:http://190.168.1.52/op1000_ota.bin) and follow next step.","title":"Step4. Add binary file to HTTP File Server"},{"location":"examples/ota_example.html#step5-issue-at-command-to-start-ota","text":"Open two terminals (such as Tera-Term application), one is DBG mode and another is AT mode. DBG mode is to check the message and AT mode is to issue AT command. The user can issue AT command at+OTA=http://<IP address>/<firmware name>.bin to start OTA. If the user success to start OTA, you will get \"OTA start\" on the terminal of DBG console like the below figure. After finishing OTA process, The \"download success\" and \"OTA finish\" messages will show in DBG console of the terminal window.","title":"Step5. Issue AT command to start OTA."},{"location":"examples/ota_example.html#ble-ota","text":"Please refer to Wi-Fi provision via BLE","title":"BLE OTA"},{"location":"examples/qd_app_example.html","text":"Start Up examples QD APP QD APP example is an entry example application of QuickDev-Framework. It includes creation of BLE service for BLE data input/out channel, Wi-FI provision via BLE, and OTA procedure via BLE. The QD APP example is located at examples\\start_up BLE service for data input/out This BLE data input/output service implements the User Data Service to send or receive data via BLE. The BLE User Data Service is in \\quick_dev\\app_ref\\ble_services\\ud_svc.c . User can issue request to device on phone app. The request will be packed as data packet and send to device. Once receiving data from phone app, the data will be transferred to the BLE Mangar through the LE task, and then the BLE Manager will transfer the data to the User Application via OPL_Service. Application will parse the data and perform indicated operation (ex. WiFi scan, WiFI connect\u2026). Device might send data to phone app also. For example, report event or status to phone app, or response the request from phone app. The application of device will issue data sending request to BLE manager. The BLE manager will send data to peer side via the service created. Wi-Fi provision via BLE Wi-Fi provision via BLE provides a mechanism to set up Wi-Fi via BLE. The Opulinks phone app provide WiFi setup function that user can perform WiFi provision via BLE to Opulinks device. User configurate Wi-Fi setup in phone app and send this request to the device (BLE peripheral) via BLE. When the phone sends Wi-Fi provision request to the device via BLE, the device utilize BLE Manager to receive this message. BLE Manager will transmit this message to application and then application will pass this message to BLE Application. BLE Application will parse this message and prepare different handler to handle different request (e.g., Wi-Fi scan request or Wi-Fi connect). These handlers would call Network Manager API to execute Wi-Fi process. When excutig Wi-Fi process done, the device wants to respnose results to the phone. Bottom layer would send Wi-Fi process response results to BLE Application via Network Manager. BLE Application would organize these Wi-Fi process response results and then pass these organized message to BLE Manager. These messages would be sent to phone by BLE Manager. Once the Wi-Fi provision via BLE is successful and Wi-Fi connection, it will automatically reconnect to the AP set by the wi-fi provision via ble after the disconnection. The following is a Wi-Fi provision via BLE example of step by step Step1. Running Opulinks Utilities app Step2. Press BLE Tool and turn on device After user turn on device, DBG console will show device mac. Step3. After press BLE Tool and turn on device, find device with the same MAC in APP scan result, and then press connect. Once connected, DBG console will show peer mac. Step4. Press Wifi Setup Once user press Wifi Setup, device will scan wifi and send result to APP. Choose an ap (ex, TOTOLINK). After user enter the password, it will pop up a window to tell user successful or failed. OTA via BLE The following is OTA via BLE example of step by step Step1. Running Opulinks Utilities app Step2. Press BLE Tool and turn on device After user turn on device, DBG console will show device mac. Step3. After press BLE Tool and turn on device, find device with the name OPL_APP_xx:xx:xx:xx (xx:xx:xx:xx are the last four significant bytes of ble mac address) in APP scan result, and then press connect. Once connected, DBG console will show peer mac. App will show the function menu (Step4). Step4. Press BLE OTA Step5. Pres Choose OTA File Step6 Choose OTA new firmware If OTA successfully, App will show","title":"Start Up"},{"location":"examples/qd_app_example.html#start-up-examples","text":"","title":"Start Up examples"},{"location":"examples/qd_app_example.html#qd-app","text":"QD APP example is an entry example application of QuickDev-Framework. It includes creation of BLE service for BLE data input/out channel, Wi-FI provision via BLE, and OTA procedure via BLE. The QD APP example is located at examples\\start_up","title":"QD APP"},{"location":"examples/qd_app_example.html#ble-service-for-data-inputout","text":"This BLE data input/output service implements the User Data Service to send or receive data via BLE. The BLE User Data Service is in \\quick_dev\\app_ref\\ble_services\\ud_svc.c . User can issue request to device on phone app. The request will be packed as data packet and send to device. Once receiving data from phone app, the data will be transferred to the BLE Mangar through the LE task, and then the BLE Manager will transfer the data to the User Application via OPL_Service. Application will parse the data and perform indicated operation (ex. WiFi scan, WiFI connect\u2026). Device might send data to phone app also. For example, report event or status to phone app, or response the request from phone app. The application of device will issue data sending request to BLE manager. The BLE manager will send data to peer side via the service created.","title":"BLE service for data input/out"},{"location":"examples/qd_app_example.html#wi-fi-provision-via-ble","text":"Wi-Fi provision via BLE provides a mechanism to set up Wi-Fi via BLE. The Opulinks phone app provide WiFi setup function that user can perform WiFi provision via BLE to Opulinks device. User configurate Wi-Fi setup in phone app and send this request to the device (BLE peripheral) via BLE. When the phone sends Wi-Fi provision request to the device via BLE, the device utilize BLE Manager to receive this message. BLE Manager will transmit this message to application and then application will pass this message to BLE Application. BLE Application will parse this message and prepare different handler to handle different request (e.g., Wi-Fi scan request or Wi-Fi connect). These handlers would call Network Manager API to execute Wi-Fi process. When excutig Wi-Fi process done, the device wants to respnose results to the phone. Bottom layer would send Wi-Fi process response results to BLE Application via Network Manager. BLE Application would organize these Wi-Fi process response results and then pass these organized message to BLE Manager. These messages would be sent to phone by BLE Manager. Once the Wi-Fi provision via BLE is successful and Wi-Fi connection, it will automatically reconnect to the AP set by the wi-fi provision via ble after the disconnection. The following is a Wi-Fi provision via BLE example of step by step Step1. Running Opulinks Utilities app Step2. Press BLE Tool and turn on device After user turn on device, DBG console will show device mac. Step3. After press BLE Tool and turn on device, find device with the same MAC in APP scan result, and then press connect. Once connected, DBG console will show peer mac. Step4. Press Wifi Setup Once user press Wifi Setup, device will scan wifi and send result to APP. Choose an ap (ex, TOTOLINK). After user enter the password, it will pop up a window to tell user successful or failed.","title":"Wi-Fi provision via BLE"},{"location":"examples/qd_app_example.html#ota-via-ble","text":"The following is OTA via BLE example of step by step Step1. Running Opulinks Utilities app Step2. Press BLE Tool and turn on device After user turn on device, DBG console will show device mac. Step3. After press BLE Tool and turn on device, find device with the name OPL_APP_xx:xx:xx:xx (xx:xx:xx:xx are the last four significant bytes of ble mac address) in APP scan result, and then press connect. Once connected, DBG console will show peer mac. App will show the function menu (Step4). Step4. Press BLE OTA Step5. Pres Choose OTA File Step6 Choose OTA new firmware If OTA successfully, App will show","title":"OTA via BLE"},{"location":"examples/wifi_example.html","text":"Wi-Fi examples Wi-Fi examples are intended to demonstrate the Wi-Fi functionality, and to provide code that you can copy and adapt into your own projects Wi-Fi scan connect Wi-Fi scan connect example is a Wi-Fi process from Wi-Fi scan to Wi-Fi connect. First executing Wi-Fi sacn, scan to the AP in the environment. According to the scanned AP results, execute Wi-Fi connect to one of these APs. This example is in examples\\wifi\\wifi_scan_connet . After APP_init , It will start systemTimer. After timer timeout , User Application will send Scan request to Network Manager. The Network Manager will call the callback function to notify the User Application Scandone after the Scan is completed. Once the Application receives the callback function, the user can use the Scan result to select the desired wifi connection and send a Connect request to the Network Manager, and the Network Manager will call the callback function to notify the User Application after connection done. Wi-Fi quick connect Wi-Fi quick connect is a example to do the fast Wi-Fi setting. The developer can set a default AP information (ssid, password), this example skips some Wi-Fi process (e.g. Wi-Fi scan) and notify the bottom layer to connect to this AP directly. If disconnecting to the default AP, this example will re-connect this AP automatically. This example is in examples\\wifi\\wifi_quick_connect . After APP_init, it will start SystemTimer. After timer timeout, User Application will get default SSID and Password from qd_config. Then Network Manager use the AP information to pass to bottom layer that implement WI-FI scan and Network Manager will clear all old AP recorders for saving this AP information to auto-connect if WI-FI disconnect then Network Manager retrieve the scan result (ex: AP bssid) to pass to bottom layer that could use the AP bssid to implement WI-FI connect. By the way, the AP information could be brought by the third party (MCU).","title":"WI-FI"},{"location":"examples/wifi_example.html#wi-fi-examples","text":"Wi-Fi examples are intended to demonstrate the Wi-Fi functionality, and to provide code that you can copy and adapt into your own projects","title":"Wi-Fi examples"},{"location":"examples/wifi_example.html#wi-fi-scan-connect","text":"Wi-Fi scan connect example is a Wi-Fi process from Wi-Fi scan to Wi-Fi connect. First executing Wi-Fi sacn, scan to the AP in the environment. According to the scanned AP results, execute Wi-Fi connect to one of these APs. This example is in examples\\wifi\\wifi_scan_connet . After APP_init , It will start systemTimer. After timer timeout , User Application will send Scan request to Network Manager. The Network Manager will call the callback function to notify the User Application Scandone after the Scan is completed. Once the Application receives the callback function, the user can use the Scan result to select the desired wifi connection and send a Connect request to the Network Manager, and the Network Manager will call the callback function to notify the User Application after connection done.","title":"Wi-Fi scan connect"},{"location":"examples/wifi_example.html#wi-fi-quick-connect","text":"Wi-Fi quick connect is a example to do the fast Wi-Fi setting. The developer can set a default AP information (ssid, password), this example skips some Wi-Fi process (e.g. Wi-Fi scan) and notify the bottom layer to connect to this AP directly. If disconnecting to the default AP, this example will re-connect this AP automatically. This example is in examples\\wifi\\wifi_quick_connect . After APP_init, it will start SystemTimer. After timer timeout, User Application will get default SSID and Password from qd_config. Then Network Manager use the AP information to pass to bottom layer that implement WI-FI scan and Network Manager will clear all old AP recorders for saving this AP information to auto-connect if WI-FI disconnect then Network Manager retrieve the scan result (ex: AP bssid) to pass to bottom layer that could use the AP bssid to implement WI-FI connect. By the way, the AP information could be brought by the third party (MCU).","title":"Wi-Fi quick connect"},{"location":"get_started/get_started.html","text":"Get Started Folder structure overview -examples : example applications -quick_dev : Quick-Dev framework program -sdk : Opulinks chip SDK Step 1. SDK download and install Download SDK you needed in Opulinks Github OPL1000_A3: https://github.com/Opulinks-Tech/OPL1000A3-SDK OPL2500_A0: https://github.com/Opulinks-Tech/OPL2500A0-SDK After downloaded, the folder struct of SDK will look like below screenshot. Copy below folder into QD_FWK\\sdk\\ FW_Pack SDK Tool Step 2. Start your first application Now the sdk prepared and ready to go, open the qd_app project in : QD_FWK\\examples\\start_up\\qd_app then into the folder base on the sdk version you just inserted. For example: If download the OPL1000_A3 sdk, then open opl1000_a3 folder in qd_app project. If download the OPL2500_A0 sdk, then open opl2500_a0 folder in qd_app project. Other sdk version likewise. Open qd_app_m3.uvprojx to start Keil application. Step 3. Connect ot Dev-Kit Connect the Dev-Kit via micro-USB Step 4. Configuration setup According to Introduction mention, QuickDev-Framework provide a easy configuration mechanism to config different kind of applications and different modules. To know the detail of the configure file, please check Project Configuration And both file qd_config.h & qd_module.h can be checked in qd_app project. Step 5. Build project Click Build and Rebuild button to compiler project. Output file qd_app_m3.bin located at <project root>\\Output\\Object\\ . Step 6. Download firmware Open download_RELEASE download tool located in sdk\\Tools\\Download\\ In Pack tag insert Script, M0 Bin, M3 Bin files. Script -> PatchData.txt ( sdk\\FW_Pack\\ ) M0 Bin -> opl1000_m0.bin ( sdk\\FW_Pack\\ ) M3 Bin -> qd_app_m3.bin ( <project root>\\Output\\Object ) Will generate opl1000.bin in sdk\\Tool\\Download\\Patch after click Pack button. In OTA tag insert OTA loader, OPL1000 Bin files. OTA loader -> opl1000_ota_loader.bin ( sdk\\FW_Pack\\ ) OPL1000 Bin -> opl1000.bin ( sdk\\Tool\\Download\\Patch\\ ) Product ID -> select to the target chip series ID. Chip ID -> select to the target chip ID. Firmware ID -> number of current project version. Checksum -> auto-calculated. Will generate opl1000_ota.bin in sdk\\Tool\\Download\\Patch after click Build OTA Image button. Select UART Port in UART Setting block which connected to Dev-Kit In Download tag insert Patch Bin file to download. Patch Bin -> opl1000_ota.bin ( sdk\\Tool\\Download\\Patch ) Click download and press reset button on Dev-Kit. Step 7. Get log Open terminal (such as Tera-Term or Putty application) and connect to the target COM port and press reset button on Dev-Kit. API support To check supported API provied from QD_FWK, locate to \\app_ref\\mngr_api\\ check the header files. Network manager - \\app_ref\\mngr_api\\net_mngr_api\\net_mngr_api.h WI-FI manager - \\app_ref\\mngr_api\\wifi_mngr_api\\wifi_mngr_api.h BLE manager - \\app_ref\\mngr_api\\ble_mngr_api\\ble_mngr_api.h","title":"Get Started"},{"location":"get_started/get_started.html#get-started","text":"","title":"Get Started"},{"location":"get_started/get_started.html#folder-structure-overview","text":"-examples : example applications -quick_dev : Quick-Dev framework program -sdk : Opulinks chip SDK","title":"Folder structure overview"},{"location":"get_started/get_started.html#step-1-sdk-download-and-install","text":"Download SDK you needed in Opulinks Github OPL1000_A3: https://github.com/Opulinks-Tech/OPL1000A3-SDK OPL2500_A0: https://github.com/Opulinks-Tech/OPL2500A0-SDK After downloaded, the folder struct of SDK will look like below screenshot. Copy below folder into QD_FWK\\sdk\\ FW_Pack SDK Tool","title":"Step 1. SDK download and install"},{"location":"get_started/get_started.html#step-2-start-your-first-application","text":"Now the sdk prepared and ready to go, open the qd_app project in : QD_FWK\\examples\\start_up\\qd_app then into the folder base on the sdk version you just inserted. For example: If download the OPL1000_A3 sdk, then open opl1000_a3 folder in qd_app project. If download the OPL2500_A0 sdk, then open opl2500_a0 folder in qd_app project. Other sdk version likewise. Open qd_app_m3.uvprojx to start Keil application.","title":"Step 2. Start your first application"},{"location":"get_started/get_started.html#step-3-connect-ot-dev-kit","text":"Connect the Dev-Kit via micro-USB","title":"Step 3. Connect ot Dev-Kit"},{"location":"get_started/get_started.html#step-4-configuration-setup","text":"According to Introduction mention, QuickDev-Framework provide a easy configuration mechanism to config different kind of applications and different modules. To know the detail of the configure file, please check Project Configuration And both file qd_config.h & qd_module.h can be checked in qd_app project.","title":"Step 4. Configuration setup"},{"location":"get_started/get_started.html#step-5-build-project","text":"Click Build and Rebuild button to compiler project. Output file qd_app_m3.bin located at <project root>\\Output\\Object\\ .","title":"Step 5. Build project"},{"location":"get_started/get_started.html#step-6-download-firmware","text":"Open download_RELEASE download tool located in sdk\\Tools\\Download\\ In Pack tag insert Script, M0 Bin, M3 Bin files. Script -> PatchData.txt ( sdk\\FW_Pack\\ ) M0 Bin -> opl1000_m0.bin ( sdk\\FW_Pack\\ ) M3 Bin -> qd_app_m3.bin ( <project root>\\Output\\Object ) Will generate opl1000.bin in sdk\\Tool\\Download\\Patch after click Pack button. In OTA tag insert OTA loader, OPL1000 Bin files. OTA loader -> opl1000_ota_loader.bin ( sdk\\FW_Pack\\ ) OPL1000 Bin -> opl1000.bin ( sdk\\Tool\\Download\\Patch\\ ) Product ID -> select to the target chip series ID. Chip ID -> select to the target chip ID. Firmware ID -> number of current project version. Checksum -> auto-calculated. Will generate opl1000_ota.bin in sdk\\Tool\\Download\\Patch after click Build OTA Image button. Select UART Port in UART Setting block which connected to Dev-Kit In Download tag insert Patch Bin file to download. Patch Bin -> opl1000_ota.bin ( sdk\\Tool\\Download\\Patch ) Click download and press reset button on Dev-Kit.","title":"Step 6. Download firmware"},{"location":"get_started/get_started.html#step-7-get-log","text":"Open terminal (such as Tera-Term or Putty application) and connect to the target COM port and press reset button on Dev-Kit.","title":"Step 7. Get log"},{"location":"get_started/get_started.html#api-support","text":"To check supported API provied from QD_FWK, locate to \\app_ref\\mngr_api\\ check the header files. Network manager - \\app_ref\\mngr_api\\net_mngr_api\\net_mngr_api.h WI-FI manager - \\app_ref\\mngr_api\\wifi_mngr_api\\wifi_mngr_api.h BLE manager - \\app_ref\\mngr_api\\ble_mngr_api\\ble_mngr_api.h","title":"API support"}]}